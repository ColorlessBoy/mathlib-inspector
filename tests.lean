-- This module serves as the root of the `MathlibInspector` library.
-- Import modules here that should be built as part of the library.
import MathlibInspector

namespace Follow

universe u_1 u v w

axiom Eq : {α : Sort u_1} -> α -> α -> Prop
axiom True : Prop
axiom Eq.refl : {α : Sort u_1} -> (a : α) -> @Eq α a a
axiom Eq.rec : {α : Sort u_1} -> {a : α} -> {motive : (a1 : α) -> @Eq α a a1 -> Sort u} -> motive a (@Eq.refl α a) -> {a1 : α} -> (t : @Eq α a a1) -> motive a1 t
axiom True.intro : True
theorem trivial : True :=
  True.intro
def rfl : {α : Sort u} -> {a : α} -> @Eq α a a :=
  fun {α : Sort u} => fun {a : α} => @Eq.refl α a
theorem Eq.symm : {α : Sort u} -> {a : α} -> {b : α} -> @Eq α a b -> @Eq α b a :=
  fun {α : Sort u} => fun {a : α} => fun {b : α} => fun (h : @Eq α a b) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => @Eq α x a) (@rfl α a) b h
theorem of_eq_true : {p : Prop} -> @Eq Prop p True -> p :=
  fun {p : Prop} => fun (h : @Eq Prop p True) => @Eq.rec Prop True (fun (x : Prop) => fun (_ : @Eq Prop True x) => x) trivial p (@Eq.symm Prop p True h)
axiom False : Prop
def Not : Prop -> Prop := fun (a : Prop) => a -> False
axiom False.rec : (motive : False -> Sort u) -> (t : False) -> motive t
noncomputable def False.elim : {C : Sort u} -> False -> C :=
  fun {C : Sort u} => fun (h : False) => @False.rec (fun (_ : False) => C) h
noncomputable def Eq.mp : {α : Sort u} -> {β : Sort u} -> @Eq (Sort u) α β -> α -> β :=
  fun {α : Sort u} => fun {β : Sort u} => fun (h : @Eq (Sort u) α β) => fun (a : α) => @Eq.rec (Sort u) α (fun (x : Sort u) => fun (_ : @Eq (Sort u) α x) => x) a β h
theorem of_eq_false : {p : Prop} -> @Eq Prop p False -> @Not p :=
  fun {p : Prop} => fun (h : @Eq Prop p False) => fun (hp : p) => @False.elim False (@Eq.mp p False h hp)
axiom Iff : Prop -> Prop -> Prop
axiom propext : {a : Prop} -> {b : Prop} -> @Iff a b -> @Eq Prop a b
axiom Iff.intro : {a : Prop} -> {b : Prop} -> (a -> b) -> (b -> a) -> @Iff a b
theorem eq_true : {p : Prop} -> p -> @Eq Prop p True :=
  fun {p : Prop} => fun (h : p) => @propext p True (@Iff.intro p True (fun (_ : p) => trivial) (fun (_ : True) => h))
noncomputable def absurd : {a : Prop} -> {b : Sort v} -> a -> @Not a -> b :=
  fun {a : Prop} => fun {b : Sort v} => fun (h₁ : a) => fun (h₂ : @Not a) => @False.rec (fun (_ : False) => b) (h₂ h₁)
theorem eq_false : {p : Prop} -> @Not p -> @Eq Prop p False :=
  fun {p : Prop} => fun (h : @Not p) => @propext p False (@Iff.intro p False (fun (h' : p) => @absurd p False h' h) (fun (h' : False) => @False.elim p h'))
theorem eq_false' : {p : Prop} -> (p -> False) -> @Eq Prop p False :=
  fun {p : Prop} => fun (h : p -> False) => @eq_false p h
axiom Decidable : Prop -> Type 0
axiom Bool : Type 0
axiom Decidable.isFalse : {p : Prop} -> @Not p -> @Decidable p
axiom Decidable.isTrue : {p : Prop} -> p -> @Decidable p
axiom Decidable.rec : {p : Prop} -> {motive : @Decidable p -> Sort u} -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> (t : @Decidable p) -> motive t
noncomputable def Decidable.casesOn : {p : Prop} -> {motive : @Decidable p -> Sort u} -> (t : @Decidable p) -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> motive t :=
  fun {p : Prop} => fun {motive : @Decidable p -> Sort u} => fun (t : @Decidable p) => fun (isFalse : (h : @Not p) -> motive (@Decidable.isFalse p h)) => fun (isTrue : (h : p) -> motive (@Decidable.isTrue p h)) => @Decidable.rec p motive (fun (h : @Not p) => isFalse h) (fun (h : p) => isTrue h) t
axiom Bool.false : Bool
axiom Bool.true : Bool
noncomputable def Decidable.decide : (p : Prop) -> @Decidable p -> Bool :=
  fun (p : Prop) => fun (h : @Decidable p) => @Decidable.casesOn p (fun (_ : @Decidable p) => Bool) h (fun (_ : @Not p) => Bool.false) (fun (_ : p) => Bool.true)
def of_decide_eq_true.match_1 : {p : Prop} -> (motive : @Decidable p -> Prop) -> (inst : @Decidable p) -> ((h₁ : p) -> motive (@Decidable.isTrue p h₁)) -> ((h₁ : @Not p) -> motive (@Decidable.isFalse p h₁)) -> motive inst :=
  fun {p : Prop} => fun (motive : @Decidable p -> Prop) => fun (inst : @Decidable p) => fun (h_1 : (h₁ : p) -> motive (@Decidable.isTrue p h₁)) => fun (h_2 : (h₁ : @Not p) -> motive (@Decidable.isFalse p h₁)) => @Decidable.casesOn p (fun (x : @Decidable p) => motive x) inst (fun (h : @Not p) => h_2 h) (fun (h : p) => h_1 h)
axiom Bool.rec : {motive : Bool -> Sort u} -> motive Bool.false -> motive Bool.true -> (t : Bool) -> motive t
noncomputable def Bool.casesOn : {motive : Bool -> Sort u} -> (t : Bool) -> motive Bool.false -> motive Bool.true -> motive t :=
  fun {motive : Bool -> Sort u} => fun (t : Bool) => fun (false : motive Bool.false) => fun (true : motive Bool.true) => @Bool.rec motive false true t
def ne_true_of_eq_false.match_1 : (motive : (x : Bool) -> @Eq Bool x Bool.false -> Prop) -> (x : Bool) -> (x1 : @Eq Bool x Bool.false) -> ((h : @Eq Bool Bool.true Bool.false) -> motive Bool.true h) -> ((x2 : @Eq Bool Bool.false Bool.false) -> motive Bool.false x2) -> motive x x1 :=
  fun (motive : (x : Bool) -> @Eq Bool x Bool.false -> Prop) => fun (x : Bool) => fun (x1 : @Eq Bool x Bool.false) => fun (h_1 : (h : @Eq Bool Bool.true Bool.false) -> motive Bool.true h) => fun (h_2 : (x2 : @Eq Bool Bool.false Bool.false) -> motive Bool.false x2) => @Bool.casesOn (fun (x2 : Bool) => (x3 : @Eq Bool x2 Bool.false) -> motive x2 x3) x (fun (x2 : @Eq Bool Bool.false Bool.false) => h_2 x2) (fun (x2 : @Eq Bool Bool.true Bool.false) => h_1 x2) x1
def Bool.noConfusionType : Sort u -> Bool -> Bool -> Sort u :=
  fun (P : Sort u) => fun (v1 : Bool) => fun (v2 : Bool) => @Bool.casesOn (fun (_ : Bool) => Sort u) v1 (@Bool.casesOn (fun (_ : Bool) => Sort u) v2 (P -> P) P) (@Bool.casesOn (fun (_ : Bool) => Sort u) v2 P (P -> P))
noncomputable def Eq.ndrec : {α : Sort u2} -> {a : α} -> {motive : α -> Sort u1} -> motive a -> {b : α} -> @Eq α a b -> motive b :=
  fun {α : Sort u2} => fun {a : α} => fun {motive : α -> Sort u1} => fun (m : motive a) => fun {b : α} => fun (h : @Eq α a b) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => motive x) m b h
axiom Bool.noConfusion.false : {P: Sort u} -> @Bool.noConfusionType P Bool.false Bool.false
axiom Bool.noConfusion.true: {P: Sort u} -> @Bool.noConfusionType P Bool.true Bool.true
axiom Bool.neq: @Not (@Eq Bool Bool.true Bool.false)
theorem Bool.neqr: @Not (@Eq Bool Bool.false Bool.true) :=
    fun (h : @Eq Bool Bool.false Bool.true) => @Bool.neq (@Eq.symm Bool Bool.false Bool.true h)
noncomputable def Bool.noConfusion : {P : Sort u} -> {v1 : Bool} -> {v2 : Bool} -> @Eq Bool v1 v2 -> @Bool.noConfusionType P v1 v2 :=
  fun {P : Sort u} => fun {v1 : Bool} => fun {v2 : Bool} => fun (h12 : @Eq Bool v1 v2) => @Eq.ndrec Bool v1 (fun (a : Bool) => @Eq Bool v1 a -> @Bool.noConfusionType P v1 a) (fun (_ : @Eq Bool v1 v1) => @Bool.casesOn (fun {v11 : Bool} => @Bool.noConfusionType P v11 v11) v1 (@Bool.noConfusion.false P) (@Bool.noConfusion.true P)) v2 h12 h12
theorem ne_true_of_eq_false : {b : Bool} -> @Eq Bool b Bool.false -> @Not (@Eq Bool b Bool.true) :=
  fun {x : Follow.Bool} => fun (x1 : @Follow.Eq Follow.Bool x Follow.Bool.false) => @Follow.ne_true_of_eq_false.match_1 (fun (x2 : Follow.Bool) => fun (_ : @Follow.Eq Follow.Bool x2 Follow.Bool.false) => @Follow.Not (@Follow.Eq Follow.Bool x2 Follow.Bool.true)) x x1 (fun (h : @Follow.Eq Follow.Bool Follow.Bool.true Follow.Bool.false) => @Follow.absurd (@Follow.Eq Follow.Bool Follow.Bool.true Follow.Bool.false) ((fun (x2 : Follow.Bool) => fun (_ : @Follow.Eq Follow.Bool x2 Follow.Bool.false) => @Follow.Not (@Follow.Eq Follow.Bool x2 Follow.Bool.true)) Follow.Bool.true h) h Follow.Bool.neq) (fun (_ : @Follow.Eq Follow.Bool Follow.Bool.false Follow.Bool.false) => Follow.Bool.neqr)
def decide_eq_false.match_1 : {p : Prop} -> (motive : @Decidable p -> @Not p -> Prop) -> (x : @Decidable p) -> (x1 : @Not p) -> ((h₁ : p) -> (h₂ : @Not p) -> motive (@Decidable.isTrue p h₁) h₂) -> ((h : @Not p) -> (x2 : @Not p) -> motive (@Decidable.isFalse p h) x2) -> motive x x1 :=
  fun {p : Prop} => fun (motive : @Decidable p -> @Not p -> Prop) => fun (x : @Decidable p) => fun (x1 : @Not p) => fun (h_1 : (h₁ : p) -> (h₂ : @Not p) -> motive (@Decidable.isTrue p h₁) h₂) => fun (h_2 : (h : @Not p) -> (x2 : @Not p) -> motive (@Decidable.isFalse p h) x2) => @Decidable.casesOn p (fun (x2 : @Decidable p) => motive x2 x1) x (fun (h : @Not p) => h_2 h x1) (fun (h : p) => h_1 h x1)
axiom decide_eq_false : {p : Prop} -> (inst : @Decidable p) -> @Not p -> @Eq Bool (@Decidable.decide p inst) Bool.false
theorem of_decide_eq_true : {p : Prop} -> (inst : @Decidable p) -> @Eq Bool (@Decidable.decide p inst) Bool.true -> p :=
  fun {p : Prop} => fun (inst : @Decidable p) => fun (h : @Eq Bool (@Decidable.decide p inst) Bool.true) => @of_decide_eq_true.match_1 p (fun (_ : @Decidable p) => p) inst (fun (h₁ : p) => h₁) (fun (h₁ : @Not p) => @absurd (@Eq Bool (@Decidable.decide p inst) Bool.true) p h (@ne_true_of_eq_false (@Decidable.decide p inst) (@decide_eq_false p inst h₁)))
theorem eq_true_of_decide : {p : Prop} -> (inst : @Decidable p) -> @Eq Bool (@Decidable.decide p inst) Bool.true -> @Eq Prop p True :=
  fun {p : Prop} => fun (inst : @Decidable p) => fun (h : @Eq Bool (@Decidable.decide p inst) Bool.true) => @eq_true p (@of_decide_eq_true p inst h)
def ne_false_of_eq_true.match_1 : (motive : (x : Bool) -> @Eq Bool x Bool.true -> Prop) -> (x : Bool) -> (x1 : @Eq Bool x Bool.true) -> ((x2 : @Eq Bool Bool.true Bool.true) -> motive Bool.true x2) -> ((h : @Eq Bool Bool.false Bool.true) -> motive Bool.false h) -> motive x x1 :=
  fun (motive : (x : Bool) -> @Eq Bool x Bool.true -> Prop) => fun (x : Bool) => fun (x1 : @Eq Bool x Bool.true) => fun (h_1 : (x2 : @Eq Bool Bool.true Bool.true) -> motive Bool.true x2) => fun (h_2 : (h : @Eq Bool Bool.false Bool.true) -> motive Bool.false h) => @Bool.casesOn (fun (x2 : Bool) => (x3 : @Eq Bool x2 Bool.true) -> motive x2 x3) x (fun (x2 : @Eq Bool Bool.false Bool.true) => h_2 x2) (fun (x2 : @Eq Bool Bool.true Bool.true) => h_1 x2) x1
theorem ne_false_of_eq_true : {b : Bool} -> @Eq Bool b Bool.true -> @Not (@Eq Bool b Bool.false) :=
  fun {x : Bool} => fun (x1 : @Eq Bool x Bool.true) => @ne_false_of_eq_true.match_1 (fun (x2 : Bool) => fun (_ : @Eq Bool x2 Bool.true) => @Not (@Eq Bool x2 Bool.false)) x x1 (fun (_ : @Eq Bool Bool.true Bool.true) => Bool.neq) (fun (h : @Eq Bool Bool.false Bool.true) => fun (_ : @Eq Bool Bool.false Bool.false) => @Bool.neqr h)
def decide_eq_true.match_1 : {p : Prop} -> (motive : @Decidable p -> p -> Prop) -> (x : @Decidable p) -> (x1 : p) -> ((h : p) -> (x2 : p) -> motive (@Decidable.isTrue p h) x2) -> ((h₁ : @Not p) -> (h₂ : p) -> motive (@Decidable.isFalse p h₁) h₂) -> motive x x1 :=
  fun {p : Prop} => fun (motive : @Decidable p -> p -> Prop) => fun (x : @Decidable p) => fun (x1 : p) => fun (h_1 : (h : p) -> (x2 : p) -> motive (@Decidable.isTrue p h) x2) => fun (h_2 : (h₁ : @Not p) -> (h₂ : p) -> motive (@Decidable.isFalse p h₁) h₂) => @Decidable.casesOn p (fun (x2 : @Decidable p) => motive x2 x1) x (fun (h : @Not p) => h_2 h x1) (fun (h : p) => h_1 h x1)
axiom decide_eq_true : {p : Prop} -> (inst : @Decidable p) -> p -> @Eq Bool (@Decidable.decide p inst) Bool.true
theorem of_decide_eq_false : {p : Prop} -> (inst : @Decidable p) -> @Eq Bool (@Decidable.decide p inst) Bool.false -> @Not p :=
  fun {p : Prop} => fun (inst : @Decidable p) => fun (h : @Eq Bool (@Decidable.decide p inst) Bool.false) => @of_decide_eq_true.match_1 p (fun (_ : @Decidable p) => @Not p) inst (fun (h₁ : p) => @absurd (@Eq Bool (@Decidable.decide p inst) Bool.false) (@Not p) h (@ne_false_of_eq_true (@Decidable.decide p inst) (@decide_eq_true p inst h₁))) (fun (h₁ : @Not p) => h₁)
theorem eq_false_of_decide : {p : Prop} -> {x : @Decidable p} -> @Eq Bool (@Decidable.decide p x) Bool.false -> @Eq Prop p False :=
  fun {p : Prop} => fun {x : @Decidable p} => fun (h : @Eq Bool (@Decidable.decide p x) Bool.false) => @eq_false p (@of_decide_eq_false p x h)
theorem implies_congr : {p₁ : Sort u} -> {p₂ : Sort u} -> {q₁ : Sort v} -> {q₂ : Sort v} -> @Eq (Sort u) p₁ p₂ -> @Eq (Sort v) q₁ q₂ -> @Eq (Sort (imax u v)) (p₁ -> q₁) (p₂ -> q₂) :=
  fun {p₁ : Sort u} => fun {p₂ : Sort u} => fun {q₁ : Sort v} => fun {q₂ : Sort v} => fun (h₁ : @Eq (Sort u) p₁ p₂) => fun (h₂ : @Eq (Sort v) q₁ q₂) => @Eq.rec (Sort u) p₁ (fun (x : Sort u) => fun (_ : @Eq (Sort u) p₁ x) => @Eq (Sort (imax u v)) (p₁ -> q₁) (x -> q₂)) (@Eq.rec (Sort v) q₁ (fun (x : Sort v) => fun (_ : @Eq (Sort v) q₁ x) => @Eq (Sort (imax u v)) (p₁ -> q₁) (p₁ -> x)) (@rfl (Sort (imax u v)) (p₁ -> q₁)) q₂ h₂) p₂ h₁
theorem Iff.refl : (a : Prop) -> @Iff a a :=
  fun (a : Prop) => @Iff.intro a a (fun (h : a) => h) (fun (h : a) => h)
theorem Iff.rfl : {a : Prop} -> @Iff a a :=
  fun {a : Prop} => @Iff.refl a
theorem Iff.of_eq : {a : Prop} -> {b : Prop} -> @Eq Prop a b -> @Iff a b :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Eq Prop a b) => @Eq.rec Prop a (fun (x : Prop) => fun (_ : @Eq Prop a x) => @Iff a x) (@Iff.rfl a) b h
theorem iff_congr : {p₁ : Prop} -> {p₂ : Prop} -> {q₁ : Prop} -> {q₂ : Prop} -> @Iff p₁ p₂ -> @Iff q₁ q₂ -> @Iff (@Iff p₁ q₁) (@Iff p₂ q₂) :=
  fun {p₁ : Prop} => fun {p₂ : Prop} => fun {q₁ : Prop} => fun {q₂ : Prop} => fun (h₁ : @Iff p₁ p₂) => fun (h₂ : @Iff q₁ q₂) => @Iff.of_eq (@Iff p₁ q₁) (@Iff p₂ q₂) (@Eq.rec Prop p₁ (fun (x : Prop) => fun (_ : @Eq Prop p₁ x) => @Eq Prop (@Iff p₁ q₁) (@Iff x q₂)) (@Eq.rec Prop q₁ (fun (x : Prop) => fun (_ : @Eq Prop q₁ x) => @Eq Prop (@Iff p₁ q₁) (@Iff p₁ x)) (@rfl Prop (@Iff p₁ q₁)) q₂ (@propext q₁ q₂ h₂)) p₂ (@propext p₁ p₂ h₁))
noncomputable def Eq.mpr : {α : Sort u} -> {β : Sort u} -> @Eq (Sort u) α β -> β -> α :=
  fun {α : Sort u} => fun {β : Sort u} => fun (h : @Eq (Sort u) α β) => fun (b : β) => @Eq.rec (Sort u) β (fun (x : Sort u) => fun (_ : @Eq (Sort u) β x) => x) b α (@Eq.symm (Sort u) α β h)
theorem implies_dep_congr_ctx : {p₁ : Prop} -> {p₂ : Prop} -> {q₁ : Prop} -> @Eq Prop p₁ p₂ -> {q₂ : p₂ -> Prop} -> ((h : p₂) -> @Eq Prop q₁ (q₂ h)) -> @Eq Prop (p₁ -> q₁) ((h : p₂) -> q₂ h) :=
  fun {p₁ : Prop} => fun {p₂ : Prop} => fun {q₁ : Prop} => fun (h₁ : @Eq Prop p₁ p₂) => fun {q₂ : p₂ -> Prop} => fun (h₂ : (h : p₂) -> @Eq Prop q₁ (q₂ h)) => @propext (p₁ -> q₁) ((h : p₂) -> q₂ h) (@Iff.intro (p₁ -> q₁) ((h : p₂) -> q₂ h) (fun (hl : p₁ -> q₁) => fun (hp₂ : p₂) => @Eq.mp q₁ (q₂ hp₂) (h₂ hp₂) (hl (@Eq.mpr p₁ p₂ h₁ hp₂))) (fun (hr : (h : p₂) -> q₂ h) => fun (hp₁ : p₁) => @Eq.mpr q₁ (q₂ (@Eq.mp p₁ p₂ h₁ hp₁)) (h₂ (@Eq.mp p₁ p₂ h₁ hp₁)) (hr (@Eq.mp p₁ p₂ h₁ hp₁))))
theorem implies_congr_ctx : {p₁ : Prop} -> {p₂ : Prop} -> {q₁ : Prop} -> {q₂ : Prop} -> @Eq Prop p₁ p₂ -> (p₂ -> @Eq Prop q₁ q₂) -> @Eq Prop (p₁ -> q₁) (p₂ -> q₂) :=
  fun {p₁ : Prop} => fun {p₂ : Prop} => fun {q₁ : Prop} => fun {q₂ : Prop} => fun (h₁ : @Eq Prop p₁ p₂) => fun (h₂ : p₂ -> @Eq Prop q₁ q₂) => @implies_dep_congr_ctx p₁ p₂ q₁ h₁ (fun (_ : p₂) => q₂) h₂
axiom Quot : {α : Sort u} -> (α -> α -> Prop) -> Sort u
axiom Quot.lift : {α : Sort u} -> {r : α -> α -> Prop} -> {β : Sort v} -> (f : α -> β) -> ((a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) -> @Quot α r -> β
noncomputable def Quot.liftOn : {α : Sort u} -> {β : Sort v} -> {r : α -> α -> Prop} -> @Quot α r -> (f : α -> β) -> ((a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) -> β :=
  fun {α : Sort u} => fun {β : Sort v} => fun {r : α -> α -> Prop} => fun (q : @Quot α r) => fun (f : α -> β) => fun (c : (a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) => @Quot.lift α r β f c q
def letFun : {α : Sort u} -> {β : α -> Sort v} -> (v : α) -> ((x : α) -> β x) -> β v :=
  fun {α : Sort u} => fun {β : α -> Sort v} => fun (v : α) => fun (f : (x : α) -> β x) => f v
axiom Quot.mk : {α : Sort u} -> (r : α -> α -> Prop) -> α -> @Quot α r
theorem congrArg : {α : Sort u} -> {β : Sort v} -> {a₁ : α} -> {a₂ : α} -> (f : α -> β) -> @Eq α a₁ a₂ -> @Eq β (f a₁) (f a₂) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {a₁ : α} => fun {a₂ : α} => fun (f : α -> β) => fun (h : @Eq α a₁ a₂) => @Eq.rec α a₁ (fun (x : α) => fun (_ : @Eq α a₁ x) => @Eq β (f a₁) (f x)) (@rfl β (f a₁)) a₂ h
axiom Quot.sound : {α : Sort u} -> {r : α -> α -> Prop} -> {a : α} -> {b : α} -> r a b -> @Eq (@Quot α r) (@Quot.mk α r a) (@Quot.mk α r b)
axiom funext : {α : Sort u} -> {β : α -> Sort v} -> {f : (x : α) -> β x} -> {g : (x : α) -> β x} -> ((x : α) -> @Eq (β x) (f x) (g x)) -> @Eq ((x : α) -> β x) f g
theorem forall_congr : {α : Sort u} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> @Eq Prop (p a) (q a)) -> @Eq Prop ((a : α) -> p a) ((a : α) -> q a) :=
  fun {α : Sort u} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> @Eq Prop (p a) (q a)) => @Eq.rec (α -> Prop) p (fun (x : α -> Prop) => fun (_ : @Eq (α -> Prop) p x) => @Eq Prop ((a : α) -> p a) ((a : α) -> x a)) (@rfl Prop ((a : α) -> p a)) q (@funext α (fun (_ : α) => Prop) p q h)
theorem Eq.substr : {α : Sort u} -> {p : α -> Prop} -> {a : α} -> {b : α} -> @Eq α b a -> p a -> p b :=
  fun {α : Sort u} => fun {p : α -> Prop} => fun {a : α} => fun {b : α} => fun (h₁ : @Eq α b a) => fun (h₂ : p a) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => p x) h₂ b (@Eq.symm α b a h₁)
theorem Eq.trans : {α : Sort u} -> {a : α} -> {b : α} -> {c : α} -> @Eq α a b -> @Eq α b c -> @Eq α a c :=
  fun {α : Sort u} => fun {a : α} => fun {b : α} => fun {c : α} => fun (h₁ : @Eq α a b) => fun (h₂ : @Eq α b c) => @Eq.rec α b (fun (x : α) => fun (_ : @Eq α b x) => @Eq α a x) h₁ c h₂
theorem eq_self : {α : Sort u_1} -> (a : α) -> @Eq Prop (@Eq α a a) True :=
  fun {α : Sort u_1} => fun (a : α) => @eq_true (@Eq α a a) (@rfl α a)
theorem forall_prop_domain_congr : {p₁ : Prop} -> {p₂ : Prop} -> {q₁ : p₁ -> Prop} -> {q₂ : p₂ -> Prop} -> (h₁ : @Eq Prop p₁ p₂) -> ((a : p₂) -> @Eq Prop (q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₂ p₁ h₁ a)) (q₂ a)) -> @Eq Prop ((a : p₁) -> q₁ a) ((a : p₂) -> q₂ a) :=
  fun {p₁ : Prop} => fun {p₂ : Prop} => fun {q₁ : p₁ -> Prop} => fun {q₂ : p₂ -> Prop} => fun (h₁ : @Eq Prop p₁ p₂) => fun (h₂ : (a : p₂) -> @Eq Prop (q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₂ p₁ h₁ a)) (q₂ a)) => @Eq.rec Prop p₁ (fun {p₂1 : Prop} => fun (h₁1 : @Eq Prop p₁ p₂1) => {q₂1 : p₂1 -> Prop} -> ((a : p₂1) -> @Eq Prop (q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₂1 p₁ h₁1 a)) (q₂1 a)) -> @Eq Prop ((a : p₁) -> q₁ a) ((a : p₂1) -> q₂1 a)) (fun {q₂1 : p₁ -> Prop} => fun (h₂1 : (a : p₁) -> @Eq Prop (q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₁ p₁ (@Eq.refl Prop p₁) a)) (q₂1 a)) => @of_eq_true (@Eq Prop ((a : p₁) -> q₁ a) ((a : p₁) -> q₂1 a)) (@Eq.trans Prop (@Eq Prop ((a : p₁) -> q₁ a) ((a : p₁) -> q₂1 a)) (@Eq Prop ((a : p₁) -> q₁ a) ((a : p₁) -> q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₁ p₁ (@Eq.refl Prop p₁) a))) True (@congrArg Prop Prop ((a : p₁) -> q₂1 a) ((a : p₁) -> q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₁ p₁ (@Eq.refl Prop p₁) a)) (@Eq Prop ((a : p₁) -> q₁ a)) (@forall_congr p₁ q₂1 (fun (a : p₁) => q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₁ p₁ (@Eq.refl Prop p₁) a)) (fun (a : p₁) => (fun (a1 : p₁) => @Eq.symm Prop (q₁ (@Eq.substr Prop (fun (x : Prop) => x) p₁ p₁ (@Eq.refl Prop p₁) a1)) (q₂1 a1) (h₂1 a1)) a))) (@eq_self Prop ((a : p₁) -> q₁ a)))) p₂ h₁ q₂ h₂
theorem forall_prop_congr_dom : {p₁ : Prop} -> {p₂ : Prop} -> (h : @Eq Prop p₁ p₂) -> (q : p₁ -> Prop) -> @Eq Prop ((a : p₁) -> q a) ((a : p₂) -> q (@Eq.substr Prop (fun (x : Prop) => x) p₂ p₁ h a)) :=
  fun {p₁ : Prop} => fun {p₂ : Prop} => fun (h : @Eq Prop p₁ p₂) => fun (q : p₁ -> Prop) => (fun (h1 : @Eq Prop ((a : p₁) -> q a) ((a : p₁) -> q a)) => @Eq.rec Prop p₁ (fun {p₂1 : Prop} => fun (h2 : @Eq Prop p₁ p₂1) => @Eq Prop ((a : p₁) -> q a) ((a : p₂1) -> q (@Eq.substr Prop (fun (x : Prop) => x) p₂1 p₁ h2 a))) h1 p₂ h) (@rfl Prop ((a : p₁) -> q a))
theorem pi_congr : {α : Sort u} -> {β : α -> Sort v} -> {β' : α -> Sort v} -> ((a : α) -> @Eq (Sort v) (β a) (β' a)) -> @Eq (Sort (imax u v)) ((a : α) -> β a) ((a : α) -> β' a) :=
  fun {α : Sort u} => fun {β : α -> Sort v} => fun {β' : α -> Sort v} => fun (h : (a : α) -> @Eq (Sort v) (β a) (β' a)) => @Eq.rec (α -> Sort v) β (fun (x : α -> Sort v) => fun (_ : @Eq (α -> Sort v) β x) => @Eq (Sort (imax u v)) ((a : α) -> β a) ((a : α) -> x a)) (@rfl (Sort (imax u v)) ((a : α) -> β a)) β' (@funext α (fun (_ : α) => Sort v) β β' h)
theorem let_congr : {α : Sort u} -> {β : Sort v} -> {a : α} -> {a' : α} -> {b : α -> β} -> {b' : α -> β} -> @Eq α a a' -> ((x : α) -> @Eq β (b x) (b' x)) -> @Eq β (let x := a ; b x) (let x := a' ; b' x) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {a : α} => fun {a' : α} => fun {b : α -> β} => fun {b' : α -> β} => fun (h₁ : @Eq α a a') => fun (h₂ : (x : α) -> @Eq β (b x) (b' x)) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => @Eq β (let x1 := a ; b x1) (let x1 := x ; b' x1)) (@Eq.rec (α -> β) b (fun (x : α -> β) => fun (_ : @Eq (α -> β) b x) => @Eq β (let x1 := a ; b x1) (let x1 := a ; x x1)) (@rfl β (let x := a ; b x)) b' (@funext α (fun (_ : α) => β) b b' h₂)) a' h₁
theorem let_val_congr : {α : Sort u} -> {β : Sort v} -> {a : α} -> {a' : α} -> (b : α -> β) -> @Eq α a a' -> @Eq β (let x := a ; b x) (let x := a' ; b x) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {a : α} => fun {a' : α} => fun (b : α -> β) => fun (h : @Eq α a a') => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => @Eq β (let x1 := a ; b x1) (let x1 := x ; b x1)) (@rfl β (let x := a ; b x)) a' h
theorem let_body_congr : {α : Sort u} -> {β : α -> Sort v} -> {b : (a : α) -> β a} -> {b' : (a : α) -> β a} -> (a : α) -> ((x : α) -> @Eq (β x) (b x) (b' x)) -> @Eq (let x := a ; β x) (let x := a ; b x) (let x := a ; b' x) :=
  fun {α : Sort u} => fun {β : α -> Sort v} => fun {b : (a : α) -> β a} => fun {b' : (a : α) -> β a} => fun (a : α) => fun (h : (x : α) -> @Eq (β x) (b x) (b' x)) => @Eq.rec ((x : α) -> β x) b (fun (x : (x : α) -> β x) => fun (_ : @Eq ((a1 : α) -> β a1) b x) => @Eq (let x1 := a ; β x1) (let x1 := a ; b x1) (let x1 := a ; x x1)) (@rfl (let x := a ; β x) (let x := a ; b x)) b' (@funext α β b b' h)
noncomputable def ite : {α : Sort u} -> (c : Prop) -> @Decidable c -> α -> α -> α :=
  fun {α : Sort u} => fun (c : Prop) => fun (h : @Decidable c) => fun (t : α) => fun (e : α) => @Decidable.casesOn c (fun (_ : @Decidable c) => α) h (fun (_ : @Not c) => e) (fun (_ : c) => t)
axiom Or : Prop -> Prop -> Prop
axiom Or.inl : {a : Prop} -> {b : Prop} -> a -> @Or a b
axiom Or.inr : {a : Prop} -> {b : Prop} -> b -> @Or a b
axiom Or.rec : {a : Prop} -> {b : Prop} -> {motive : @Or a b -> Prop} -> ((h : a) -> motive (@Or.inl a b h)) -> ((h : b) -> motive (@Or.inr a b h)) -> (t : @Or a b) -> motive t
def Or.casesOn : {a : Prop} -> {b : Prop} -> {motive : @Or a b -> Prop} -> (t : @Or a b) -> ((h : a) -> motive (@Or.inl a b h)) -> ((h : b) -> motive (@Or.inr a b h)) -> motive t :=
  fun {a : Prop} => fun {b : Prop} => fun {motive : @Or a b -> Prop} => fun (t : @Or a b) => fun (inl : (h : a) -> motive (@Or.inl a b h)) => fun (inr : (h : b) -> motive (@Or.inr a b h)) => @Or.rec a b motive (fun (h : a) => inl h) (fun (h : b) => inr h) t
noncomputable def Decidable.byCases.match_1 : {p : Prop} -> (motive : @Decidable p -> Sort u_1) -> (dec : @Decidable p) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> motive dec :=
  fun {p : Prop} => fun (motive : @Decidable p -> Sort u_1) => fun (dec : @Decidable p) => fun (h_1 : (h : p) -> motive (@Decidable.isTrue p h)) => fun (h_2 : (h : @Not p) -> motive (@Decidable.isFalse p h)) => @Decidable.casesOn p (fun (x : @Decidable p) => motive x) dec (fun (h : @Not p) => h_2 h) (fun (h : p) => h_1 h)
noncomputable def Decidable.byCases : {p : Prop} -> {q : Sort u} -> @Decidable p -> (p -> q) -> (@Not p -> q) -> q :=
  fun {p : Prop} => fun {q : Sort u} => fun (dec : @Decidable p) => fun (h1 : p -> q) => fun (h2 : @Not p -> q) => @Decidable.byCases.match_1 p (fun (_ : @Decidable p) => q) dec (fun (h : p) => h1 h) (fun (h : @Not p) => h2 h)
theorem Decidable.em : (p : Prop) -> @Decidable p -> @Or p (@Not p) :=
  fun (p : Prop) => fun (inst : @Decidable p) => @Decidable.byCases p (@Or p (@Not p)) inst (@Or.inl p (@Not p)) (@Or.inr p (@Not p))
def id : {α : Sort u} -> α -> α :=
  fun {α : Sort u} => fun (a : α) => a
def if_pos.match_1 : {c : Prop} -> (motive : @Decidable c -> Prop) -> (h : @Decidable c) -> ((h1 : c) -> motive (@Decidable.isTrue c h1)) -> ((hnc : @Not c) -> motive (@Decidable.isFalse c hnc)) -> motive h :=
  fun {c : Prop} => fun (motive : @Decidable c -> Prop) => fun (h : @Decidable c) => fun (h_1 : (h1 : c) -> motive (@Decidable.isTrue c h1)) => fun (h_2 : (hnc : @Not c) -> motive (@Decidable.isFalse c hnc)) => @Decidable.casesOn c (fun (x : @Decidable c) => motive x) h (fun (h1 : @Not c) => h_2 h1) (fun (h1 : c) => h_1 h1)
axiom if_pos : {c : Prop} -> {h : @Decidable c} -> c -> {α : Sort u} -> {t : α} -> {e : α} -> @Eq α (@ite α c h t e) t
axiom if_neg : {c : Prop} -> {h : @Decidable c} -> @Not c -> {α : Sort u} -> {t : α} -> {e : α} -> @Eq α (@ite α c h t e) e
theorem ite_congr : {α : Sort u_1} -> {b : Prop} -> {c : Prop} -> {x : α} -> {y : α} -> {u : α} -> {v : α} -> {s : @Decidable b} -> (inst : @Decidable c) -> @Eq Prop b c -> (c -> @Eq α x u) -> (@Not c -> @Eq α y v) -> @Eq α (@ite α b s x y) (@ite α c inst u v) :=
  fun {α : Sort u_1} => fun {b : Prop} => fun {c : Prop} => fun {x : α} => fun {y : α} => fun {u : α} => fun {v : α} => fun {s : @Decidable b} => fun (inst : @Decidable c) => fun (h₁ : @Eq Prop b c) => fun (h₂ : c -> @Eq α x u) => fun (h₃ : @Not c -> @Eq α y v) => @Or.casesOn c (@Not c) (fun (t : @Or c (@Not c)) => @Eq (@Or c (@Not c)) (@Decidable.em c inst) t -> @Eq α (@ite α b s x y) (@ite α c inst u v)) (@Decidable.em c inst) (fun (h : c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inl c (@Not c) h)) => @Eq.mpr (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) u) (@id (@Eq Prop (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) u)) (@congrArg α Prop (@ite α c inst u v) u (fun (_a : α) => @Eq α (@ite α b s x y) _a) (@if_pos c inst h α u v))) (@Eq.ndrec Prop c (fun {b1 : Prop} => {s1 : @Decidable b1} -> @Eq α (@ite α b1 s1 x y) u) (fun {s1 : @Decidable c} => @Eq.mpr (@Eq α (@ite α c s1 x y) u) (@Eq α x u) (@id (@Eq Prop (@Eq α (@ite α c s1 x y) u) (@Eq α x u)) (@congrArg α Prop (@ite α c s1 x y) x (fun (_a : α) => @Eq α _a u) (@if_pos c s1 h α x y))) (h₂ h)) b (@Eq.symm Prop b c h₁) s)) (fun (h : @Not c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inr c (@Not c) h)) => @Eq.mpr (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) v) (@id (@Eq Prop (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) v)) (@congrArg α Prop (@ite α c inst u v) v (fun (_a : α) => @Eq α (@ite α b s x y) _a) (@if_neg c inst h α u v))) (@Eq.ndrec Prop c (fun {b1 : Prop} => {s1 : @Decidable b1} -> @Eq α (@ite α b1 s1 x y) v) (fun {s1 : @Decidable c} => @Eq.mpr (@Eq α (@ite α c s1 x y) v) (@Eq α y v) (@id (@Eq Prop (@Eq α (@ite α c s1 x y) v) (@Eq α y v)) (@congrArg α Prop (@ite α c s1 x y) y (fun (_a : α) => @Eq α _a v) (@if_neg c s1 h α x y))) (h₃ h)) b (@Eq.symm Prop b c h₁) s)) (@Eq.refl (@Or c (@Not c)) (@Decidable.em c inst))
theorem Eq.mpr_prop : {p : Prop} -> {q : Prop} -> @Eq Prop p q -> q -> p :=
  fun {p : Prop} => fun {q : Prop} => fun (h₁ : @Eq Prop p q) => fun (h₂ : q) => @Eq.rec Prop q (fun (x : Prop) => fun (_ : @Eq Prop q x) => x) h₂ p (@Eq.symm Prop p q h₁)
theorem Eq.mpr_not : {p : Prop} -> {q : Prop} -> @Eq Prop p q -> @Not q -> @Not p :=
  fun {p : Prop} => fun {q : Prop} => fun (h₁ : @Eq Prop p q) => fun (h₂ : @Not q) => @Eq.rec Prop q (fun (x : Prop) => fun (_ : @Eq Prop q x) => @Not x) h₂ p (@Eq.symm Prop p q h₁)
noncomputable def dite : {α : Sort u} -> (c : Prop) -> @Decidable c -> (c -> α) -> (@Not c -> α) -> α :=
  fun {α : Sort u} => fun (c : Prop) => fun (h : @Decidable c) => fun (t : c -> α) => fun (e : @Not c -> α) => @Decidable.casesOn c (fun (_ : @Decidable c) => α) h e t
axiom dif_pos : {c : Prop} -> {h : @Decidable c} -> (hc : c) -> {α : Sort u} -> {t : c -> α} -> {e : @Not c -> α} -> @Eq α (@dite α c h t e) (t hc)
axiom dif_neg : {c : Prop} -> {h : @Decidable c} -> (hnc : @Not c) -> {α : Sort u} -> {t : c -> α} -> {e : @Not c -> α} -> @Eq α (@dite α c h t e) (e hnc)
theorem dite_congr : {b : Prop} -> {c : Prop} -> {α : Sort u_1} -> {x : @Decidable b} -> (inst : @Decidable c) -> {x1 : b -> α} -> {u : c -> α} -> {y : @Not b -> α} -> {v : @Not c -> α} -> (h₁ : @Eq Prop b c) -> ((h : c) -> @Eq α (x1 (@Eq.mpr_prop b c h₁ h)) (u h)) -> ((h : @Not c) -> @Eq α (y (@Eq.mpr_not b c h₁ h)) (v h)) -> @Eq α (@dite α b x x1 y) (@dite α c inst u v) :=
  fun {b : Prop} => fun {c : Prop} => fun {α : Sort u_1} => fun {x : @Decidable b} => fun (inst : @Decidable c) => fun {x1 : b -> α} => fun {u : c -> α} => fun {y : @Not b -> α} => fun {v : @Not c -> α} => fun (h₁ : @Eq Prop b c) => fun (h₂ : (h : c) -> @Eq α (x1 (@Eq.mpr_prop b c h₁ h)) (u h)) => fun (h₃ : (h : @Not c) -> @Eq α (y (@Eq.mpr_not b c h₁ h)) (v h)) => @Or.casesOn c (@Not c) (fun (t : @Or c (@Not c)) => @Eq (@Or c (@Not c)) (@Decidable.em c inst) t -> @Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Decidable.em c inst) (fun (h : c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inl c (@Not c) h)) => @Eq.mpr (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (u h)) (@id (@Eq Prop (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (u h))) (@congrArg α Prop (@dite α c inst u v) (u h) (fun (_a : α) => @Eq α (@dite α b x x1 y) _a) (@dif_pos c inst h α u v))) (@Eq.rec Prop c (fun {b1 : Prop} => fun (_h : @Eq Prop c b1) => {x2 : @Decidable b1} -> {x3 : b1 -> α} -> {y1 : @Not b1 -> α} -> ((h2 : c) -> @Eq α (x3 (@Eq.mpr_prop b1 c (@Eq.symm Prop c b1 _h) h2)) (u h2)) -> ((h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not b1 c (@Eq.symm Prop c b1 _h) h2)) (v h2)) -> @Eq α (@dite α b1 x2 x3 y1) (u h)) (fun {x2 : @Decidable c} => fun {x3 : c -> α} => fun {y1 : @Not c -> α} => fun (h₂1 : (h2 : c) -> @Eq α (x3 (@Eq.mpr_prop c c (@Eq.refl Prop c) h2)) (u h2)) => fun (_ : (h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not c c (@Eq.refl Prop c) h2)) (v h2)) => @Eq.mpr (@Eq α (@dite α c x2 x3 y1) (u h)) (@Eq α (x3 h) (u h)) (@id (@Eq Prop (@Eq α (@dite α c x2 x3 y1) (u h)) (@Eq α (x3 h) (u h))) (@congrArg α Prop (@dite α c x2 x3 y1) (x3 h) (fun (_a : α) => @Eq α _a (u h)) (@dif_pos c x2 h α x3 y1))) (h₂1 h)) b (@Eq.symm Prop b c h₁) x x1 y h₂ h₃)) (fun (h : @Not c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inr c (@Not c) h)) => @Eq.mpr (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (v h)) (@id (@Eq Prop (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (v h))) (@congrArg α Prop (@dite α c inst u v) (v h) (fun (_a : α) => @Eq α (@dite α b x x1 y) _a) (@dif_neg c inst h α u v))) (@Eq.rec Prop c (fun {b1 : Prop} => fun (_h : @Eq Prop c b1) => {x2 : @Decidable b1} -> {x3 : b1 -> α} -> {y1 : @Not b1 -> α} -> ((h2 : c) -> @Eq α (x3 (@Eq.mpr_prop b1 c (@Eq.symm Prop c b1 _h) h2)) (u h2)) -> ((h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not b1 c (@Eq.symm Prop c b1 _h) h2)) (v h2)) -> @Eq α (@dite α b1 x2 x3 y1) (v h)) (fun {x2 : @Decidable c} => fun {x3 : c -> α} => fun {y1 : @Not c -> α} => fun (_ : (h2 : c) -> @Eq α (x3 (@Eq.mpr_prop c c (@Eq.refl Prop c) h2)) (u h2)) => fun (h₃1 : (h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not c c (@Eq.refl Prop c) h2)) (v h2)) => @Eq.mpr (@Eq α (@dite α c x2 x3 y1) (v h)) (@Eq α (y1 h) (v h)) (@id (@Eq Prop (@Eq α (@dite α c x2 x3 y1) (v h)) (@Eq α (y1 h) (v h))) (@congrArg α Prop (@dite α c x2 x3 y1) (y1 h) (fun (_a : α) => @Eq α _a (v h)) (@dif_neg c x2 h α x3 y1))) (h₃1 h)) b (@Eq.symm Prop b c h₁) x x1 y h₂ h₃)) (@Eq.refl (@Or c (@Not c)) (@Decidable.em c inst))
noncomputable def instDecidableTrue : @Decidable True :=
  @Decidable.isTrue True trivial
axiom ite_cond_eq_true : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> (a : α) -> (b : α) -> @Eq Prop c True -> @Eq α (@ite α c x a b) a
theorem not_false : @Not False :=
  @id False
noncomputable def instDecidableFalse : @Decidable False :=
  @Decidable.isFalse False not_false
axiom ite_cond_eq_false : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> (a : α) -> (b : α) -> @Eq Prop c False -> @Eq α (@ite α c x a b) b
axiom dite_cond_eq_true : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> {t : c -> α} -> {e : @Not c -> α} -> (h : @Eq Prop c True) -> @Eq α (@dite α c x t e) (t (@of_eq_true c h))
axiom dite_cond_eq_false : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> {t : c -> α} -> {e : @Not c -> α} -> (h : @Eq Prop c False) -> @Eq α (@dite α c x t e) (e (@of_eq_false c h))
axiom And : Prop -> Prop -> Prop
axiom And.intro : {a : Prop} -> {b : Prop} -> a -> b -> @And a b
axiom And.rec : {a : Prop} -> {b : Prop} -> {motive : @And a b -> Sort u} -> ((left : a) -> (right : b) -> motive (@And.intro a b left right)) -> (t : @And a b) -> motive t
noncomputable def And.casesOn : {a : Prop} -> {b : Prop} -> {motive : @And a b -> Sort u} -> (t : @And a b) -> ((left : a) -> (right : b) -> motive (@And.intro a b left right)) -> motive t :=
  fun {a : Prop} => fun {b : Prop} => fun {motive : @And a b -> Sort u} => fun (t : @And a b) => fun (intro : (left : a) -> (right : b) -> motive (@And.intro a b left right)) => @And.rec a b motive (fun (left : a) => fun (right : b) => intro left right) t
def and_imp.match_1 : {a : Prop} -> {b : Prop} -> (motive : @And a b -> Prop) -> (x : @And a b) -> ((ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @And a b -> Prop) => fun (x : @And a b) => fun (h_1 : (ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) => @And.casesOn a b (fun (x1 : @And a b) => motive x1) x (fun (left : a) => fun (right : b) => h_1 left right)
axiom Iff.mp : {a : Prop} -> {b : Prop} -> @Iff a b -> a -> b
axiom Iff.mpr : {a : Prop} -> {b : Prop} -> @Iff a b -> b -> a
theorem and_congr_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> @Iff b c) -> @Iff (@And a b) (@And a c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> @Iff b c) => @Iff.intro (@And a b) (@And a c) (fun (x : @And a b) => @and_imp.match_1 a b (fun (_ : @And a b) => @And a c) x (fun (ha : a) => fun (hb : b) => @And.intro a c ha (@Iff.mp b c (h ha) hb))) (fun (x : @And a c) => @and_imp.match_1 a c (fun (_ : @And a c) => @And a b) x (fun (ha : a) => fun (hb : c) => @And.intro a b ha (@Iff.mpr b c (h ha) hb)))
def Function.comp : {α : Sort u} -> {β : Sort v} -> {δ : Sort w} -> (β -> δ) -> (α -> β) -> α -> δ :=
  fun {α : Sort u} => fun {β : Sort v} => fun {δ : Sort w} => fun (f : β -> δ) => fun (g : α -> β) => fun (x : α) => f (g x)
theorem Iff.trans : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff a b -> @Iff b c -> @Iff a c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h₁ : @Iff a b) => fun (h₂ : @Iff b c) => @Iff.intro a c (@Function.comp a b c (@Iff.mp b c h₂) (@Iff.mp a b h₁)) (@Function.comp c b a (@Iff.mpr a b h₁) (@Iff.mpr b c h₂))
def And.symm.match_1 : {a : Prop} -> {b : Prop} -> (motive : @And a b -> Prop) -> (x : @And a b) -> ((ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @And a b -> Prop) => fun (x : @And a b) => fun (h_1 : (ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) => @And.casesOn a b (fun (x1 : @And a b) => motive x1) x (fun (left : a) => fun (right : b) => h_1 left right)
theorem And.symm : {a : Prop} -> {b : Prop} -> @And a b -> @And b a :=
  fun {a : Prop} => fun {b : Prop} => fun (x : @And a b) => @And.symm.match_1 a b (fun (_ : @And a b) => @And b a) x (fun (ha : a) => fun (hb : b) => @And.intro b a hb ha)
theorem And.comm : {a : Prop} -> {b : Prop} -> @Iff (@And a b) (@And b a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@And a b) (@And b a) (@And.symm a b) (@And.symm b a)
theorem and_comm : {a : Prop} -> {b : Prop} -> @Iff (@And a b) (@And b a) :=
  fun {a : Prop} => fun {b : Prop} => @And.comm a b
theorem and_congr_left : {c : Prop} -> {a : Prop} -> {b : Prop} -> (c -> @Iff a b) -> @Iff (@And a c) (@And b c) :=
  fun {c : Prop} => fun {a : Prop} => fun {b : Prop} => fun (h : c -> @Iff a b) => @Iff.trans (@And a c) (@And c a) (@And b c) (@and_comm a c) (@Iff.trans (@And c a) (@And c b) (@And b c) (@and_congr_right c a b h) (@and_comm c b))
def and_assoc.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And (@And a b) c -> Prop) -> (x : @And (@And a b) c) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And (@And a b) c -> Prop) => fun (x : @And (@And a b) c) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) => @And.casesOn (@And a b) c (fun (x1 : @And (@And a b) c) => motive x1) x (fun (left : @And a b) => fun (right : c) => @And.casesOn a b (fun (x1 : @And a b) => motive (@And.intro (@And a b) c x1 right)) left (fun (left1 : a) => fun (right1 : b) => h_1 left1 right1 right))
def and_assoc.match_2 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And a (@And b c) -> Prop) -> (x : @And a (@And b c)) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And a (@And b c) -> Prop) => fun (x : @And a (@And b c)) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) => @And.casesOn a (@And b c) (fun (x1 : @And a (@And b c)) => motive x1) x (fun (left : a) => fun (right : @And b c) => @And.casesOn b c (fun (x1 : @And b c) => motive (@And.intro a (@And b c) left x1)) right (fun (left1 : b) => fun (right1 : c) => h_1 left left1 right1))
theorem and_assoc : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And (@And a b) c) (@And a (@And b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And (@And a b) c) (@And a (@And b c)) (fun (x : @And (@And a b) c) => @and_assoc.match_1 a b c (fun (_ : @And (@And a b) c) => @And a (@And b c)) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro a (@And b c) ha (@And.intro b c hb hc))) (fun (x : @And a (@And b c)) => @and_assoc.match_2 a b c (fun (_ : @And a (@And b c)) => @And (@And a b) c) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro (@And a b) c (@And.intro a b ha hb) hc))
axiom And.left : {a : Prop} -> {b : Prop} -> @And a b -> a
theorem and_iff_left_of_imp : {a : Prop} -> {b : Prop} -> (a -> b) -> @Iff (@And a b) a :=
  fun {a : Prop} => fun {b : Prop} => fun (h : a -> b) => @Iff.intro (@And a b) a (@And.left a b) (fun (ha : a) => @And.intro a b ha (h ha))
theorem and_iff_right_of_imp : {b : Prop} -> {a : Prop} -> (b -> a) -> @Iff (@And a b) b :=
  fun {b : Prop} => fun {a : Prop} => fun (h : b -> a) => @Iff.trans (@And a b) (@And b a) b (@And.comm a b) (@and_iff_left_of_imp b a h)
def Or.elim.match_1 : {a : Prop} -> {b : Prop} -> (motive : @Or a b -> Prop) -> (h : @Or a b) -> ((h1 : a) -> motive (@Or.inl a b h1)) -> ((h1 : b) -> motive (@Or.inr a b h1)) -> motive h :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @Or a b -> Prop) => fun (h : @Or a b) => fun (h_1 : (h1 : a) -> motive (@Or.inl a b h1)) => fun (h_2 : (h1 : b) -> motive (@Or.inr a b h1)) => @Or.casesOn a b (fun (x : @Or a b) => motive x) h (fun (h1 : a) => h_1 h1) (fun (h1 : b) => h_2 h1)
theorem Or.elim : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Or a b -> (a -> c) -> (b -> c) -> c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : @Or a b) => fun (left : a -> c) => fun (right : b -> c) => @Or.elim.match_1 a b (fun (_ : @Or a b) => c) h (fun (h1 : a) => left h1) (fun (h1 : b) => right h1)
theorem Or.imp : {a : Prop} -> {c : Prop} -> {b : Prop} -> {d : Prop} -> (a -> c) -> (b -> d) -> @Or a b -> @Or c d :=
  fun {a : Prop} => fun {c : Prop} => fun {b : Prop} => fun {d : Prop} => fun (f : a -> c) => fun (g : b -> d) => fun (h : @Or a b) => @Or.elim a b (@Or c d) h (@Function.comp a c (@Or c d) (@Or.inl c d) f) (@Function.comp b d (@Or c d) (@Or.inr c d) g)
theorem Or.imp_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> b) -> @Or a c -> @Or b c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (f : a -> b) => @Or.imp a b c c f (@id c)
theorem Or.imp_right : {b : Prop} -> {c : Prop} -> {a : Prop} -> (b -> c) -> @Or a b -> @Or a c :=
  fun {b : Prop} => fun {c : Prop} => fun {a : Prop} => fun (f : b -> c) => @Or.imp a a b c (@id a) f
theorem or_assoc : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or (@Or a b) c) (@Or a (@Or b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@Or (@Or a b) c) (@Or a (@Or b c)) (fun (t : @Or (@Or a b) c) => @Or.rec (@Or a b) c (fun (_ : @Or (@Or a b) c) => @Or a (@Or b c)) (@Or.imp_right b (@Or b c) a (@Or.inl b c)) (@Function.comp c (@Or b c) (@Or a (@Or b c)) (@Or.inr a (@Or b c)) (@Or.inr b c)) t) (fun (t : @Or a (@Or b c)) => @Or.rec a (@Or b c) (fun (_ : @Or a (@Or b c)) => @Or (@Or a b) c) (@Function.comp a (@Or a b) (@Or (@Or a b) c) (@Or.inl (@Or a b) c) (@Or.inl a b)) (@Or.imp_left b (@Or a b) c (@Or.inr a b)) t)
theorem or_iff_right_of_imp : {a : Prop} -> {b : Prop} -> (a -> b) -> @Iff (@Or a b) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a -> b) => @Iff.intro (@Or a b) b (fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => b) ha (@id b) t) (@Or.inr a b)
theorem or_iff_left_of_imp : {b : Prop} -> {a : Prop} -> (b -> a) -> @Iff (@Or a b) a :=
  fun {b : Prop} => fun {a : Prop} => fun (hb : b -> a) => @Iff.intro (@Or a b) a (fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => a) (@id a) hb t) (@Or.inl a b)
axiom PUnit : Sort u
def Unit : Type 0 :=
  PUnit
axiom PUnit.unit : PUnit
noncomputable def Unit.unit : Unit := PUnit.unit
noncomputable def Bool.and.match_1 : (motive : Bool -> Sort u_1) -> (x : Bool) -> (Unit -> motive Bool.false) -> (Unit -> motive Bool.true) -> motive x :=
  fun (motive : Bool -> Sort u_1) => fun (x : Bool) => fun (h_1 : Unit -> motive Bool.false) => fun (h_2 : Unit -> motive Bool.true) => @Bool.casesOn (fun (x1 : Bool) => motive x1) x (h_1 Unit.unit) (h_2 Unit.unit)
noncomputable def Bool.and : Bool -> Bool -> Bool :=
  fun (x : Bool) => fun (y : Bool) => @Bool.and.match_1 (fun (_ : Bool) => Bool) x (fun (_ : Unit) => Bool.false) (fun (_ : Unit) => y)
def DecidableEq : Sort u -> Sort (max (0 + 1) u) :=
  fun (α : Sort u) => (a : α) -> (b : α) -> @Decidable (@Eq α a b)
noncomputable def Bool.decEq.match_1 : (motive : Bool -> Bool -> Sort u_1) -> (a : Bool) -> (b : Bool) -> (Unit -> motive Bool.false Bool.false) -> (Unit -> motive Bool.false Bool.true) -> (Unit -> motive Bool.true Bool.false) -> (Unit -> motive Bool.true Bool.true) -> motive a b :=
  fun (motive : Bool -> Bool -> Sort u_1) => fun (a : Bool) => fun (b : Bool) => fun (h_1 : Unit -> motive Bool.false Bool.false) => fun (h_2 : Unit -> motive Bool.false Bool.true) => fun (h_3 : Unit -> motive Bool.true Bool.false) => fun (h_4 : Unit -> motive Bool.true Bool.true) => @Bool.casesOn (fun (x : Bool) => motive x b) a (@Bool.casesOn (fun (x : Bool) => motive Bool.false x) b (h_1 Unit.unit) (h_2 Unit.unit)) (@Bool.casesOn (fun (x : Bool) => motive Bool.true x) b (h_3 Unit.unit) (h_4 Unit.unit))
noncomputable def Bool.decEq : (a : Bool) -> (b : Bool) -> @Decidable (@Eq Bool a b) :=
  fun (a : Bool) => fun (b : Bool) => @Bool.decEq.match_1 (fun (a1 : Bool) => fun (b1 : Bool) => @Decidable (@Eq Bool a1 b1)) a b (fun (_ : Unit) => @Decidable.isTrue (@Eq Bool Bool.false Bool.false) (@rfl Bool Bool.false)) (fun (_ : Unit) => @Decidable.isFalse (@Eq Bool Bool.false Bool.true) Bool.neqr) (fun (_ : Unit) => @Decidable.isFalse (@Eq Bool Bool.true Bool.false) Bool.neq) (fun (_ : Unit) => @Decidable.isTrue (@Eq Bool Bool.true Bool.true) (@rfl Bool Bool.true))
noncomputable def instDecidableEqBool : @DecidableEq Bool :=
  Bool.decEq
theorem Bool.and_assoc : (a : Bool) -> (b : Bool) -> (c : Bool) -> @Eq Bool (@Bool.and (@Bool.and a b) c) (@Bool.and a (@Bool.and b c)) :=
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Eq Bool (@Bool.and (@Bool.and a b) c) (@Bool.and a (@Bool.and b c))) a (fun (h : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun (a1 : Bool) => @Eq Bool (@Bool.and (@Bool.and a1 b) c) (@Bool.and a1 (@Bool.and b c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.and (@Bool.and Bool.false b) c) (@Bool.and Bool.false (@Bool.and b c))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false b1) c) (@Bool.and Bool.false (@Bool.and b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) c) (@Bool.and Bool.false (@Bool.and Bool.false c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) c1) (@Bool.and Bool.false (@Bool.and Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.false Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.false Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.false Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.false Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) c1) (@Bool.and Bool.false (@Bool.and Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.false Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.false Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.false Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.false) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.false Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false b1) c) (@Bool.and Bool.false (@Bool.and b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) c) (@Bool.and Bool.false (@Bool.and Bool.true c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) c1) (@Bool.and Bool.false (@Bool.and Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.true Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.true Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.true Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.false) (@Bool.and Bool.false (@Bool.and Bool.true Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) c1) (@Bool.and Bool.false (@Bool.and Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.true Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.true Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.true Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.false Bool.true) Bool.true) (@Bool.and Bool.false (@Bool.and Bool.true Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.false h)) (fun (h : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun (a1 : Bool) => @Eq Bool (@Bool.and (@Bool.and a1 b) c) (@Bool.and a1 (@Bool.and b c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.and (@Bool.and Bool.true b) c) (@Bool.and Bool.true (@Bool.and b c))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true b1) c) (@Bool.and Bool.true (@Bool.and b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) c) (@Bool.and Bool.true (@Bool.and Bool.false c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) c1) (@Bool.and Bool.true (@Bool.and Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.false Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.false Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.false Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.false Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) c1) (@Bool.and Bool.true (@Bool.and Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.false Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.false Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.false Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.false) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.false Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true b1) c) (@Bool.and Bool.true (@Bool.and b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) c) (@Bool.and Bool.true (@Bool.and Bool.true c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) c1) (@Bool.and Bool.true (@Bool.and Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.true Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.true Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.true Bool.false))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.false) (@Bool.and Bool.true (@Bool.and Bool.true Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) c1) (@Bool.and Bool.true (@Bool.and Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.true Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.true Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.true Bool.true))) (@instDecidableEqBool (@Bool.and (@Bool.and Bool.true Bool.true) Bool.true) (@Bool.and Bool.true (@Bool.and Bool.true Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.true h)) (@Eq.refl Bool a)
noncomputable def cond.match_1 : (motive : Bool -> Sort u_1) -> (c : Bool) -> (Unit -> motive Bool.true) -> (Unit -> motive Bool.false) -> motive c :=
  fun (motive : Bool -> Sort u_1) => fun (c : Bool) => fun (h_1 : Unit -> motive Bool.true) => fun (h_2 : Unit -> motive Bool.false) => @Bool.casesOn (fun (x : Bool) => motive x) c (h_2 Unit.unit) (h_1 Unit.unit)
noncomputable def Bool.or : Bool -> Bool -> Bool :=
  fun (x : Bool) => fun (y : Bool) => @cond.match_1 (fun (_ : Bool) => Bool) x (fun (_ : Unit) => Bool.true) (fun (_ : Unit) => y)
theorem Bool.or_assoc : (a : Bool) -> (b : Bool) -> (c : Bool) -> @Eq Bool (@Bool.or (@Bool.or a b) c) (@Bool.or a (@Bool.or b c)) :=
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Eq Bool (@Bool.or (@Bool.or a b) c) (@Bool.or a (@Bool.or b c))) a (fun (h : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun (a1 : Bool) => @Eq Bool (@Bool.or (@Bool.or a1 b) c) (@Bool.or a1 (@Bool.or b c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.or (@Bool.or Bool.false b) c) (@Bool.or Bool.false (@Bool.or b c))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false b1) c) (@Bool.or Bool.false (@Bool.or b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) c) (@Bool.or Bool.false (@Bool.or Bool.false c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) c1) (@Bool.or Bool.false (@Bool.or Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.false Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.false Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.false Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.false Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) c1) (@Bool.or Bool.false (@Bool.or Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.false Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.false Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.false Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.false) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.false Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false b1) c) (@Bool.or Bool.false (@Bool.or b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) c) (@Bool.or Bool.false (@Bool.or Bool.true c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) c1) (@Bool.or Bool.false (@Bool.or Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.true Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.true Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.true Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.false) (@Bool.or Bool.false (@Bool.or Bool.true Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) c1) (@Bool.or Bool.false (@Bool.or Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.true Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.true Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.true Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.false Bool.true) Bool.true) (@Bool.or Bool.false (@Bool.or Bool.true Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.false h)) (fun (h : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun (a1 : Bool) => @Eq Bool (@Bool.or (@Bool.or a1 b) c) (@Bool.or a1 (@Bool.or b c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.or (@Bool.or Bool.true b) c) (@Bool.or Bool.true (@Bool.or b c))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true b1) c) (@Bool.or Bool.true (@Bool.or b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) c) (@Bool.or Bool.true (@Bool.or Bool.false c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) c1) (@Bool.or Bool.true (@Bool.or Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.false Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.false Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.false Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.false Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) c1) (@Bool.or Bool.true (@Bool.or Bool.false c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.false Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.false Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.false Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.false) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.false Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true b1) c) (@Bool.or Bool.true (@Bool.or b1 c))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool c t -> @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) c) (@Bool.or Bool.true (@Bool.or Bool.true c))) c (fun (h2 : @Eq Bool c Bool.false) => @Eq.ndrec Bool Bool.false (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) c1) (@Bool.or Bool.true (@Bool.or Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.true Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.true Bool.false))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.true Bool.false))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.false) (@Bool.or Bool.true (@Bool.or Bool.true Bool.false)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.false h2)) (fun (h2 : @Eq Bool c Bool.true) => @Eq.ndrec Bool Bool.true (fun (c1 : Bool) => @Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) c1) (@Bool.or Bool.true (@Bool.or Bool.true c1))) (@of_decide_eq_true (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.true Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.true Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.true Bool.true))) (@instDecidableEqBool (@Bool.or (@Bool.or Bool.true Bool.true) Bool.true) (@Bool.or Bool.true (@Bool.or Bool.true Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) c (@Eq.symm Bool c Bool.true h2)) (@Eq.refl Bool c)) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.true h)) (@Eq.refl Bool a)
noncomputable def Bool.not : Bool -> Bool :=
  fun (x : Bool) => @cond.match_1 (fun (_ : Bool) => Bool) x (fun (_ : Unit) => Bool.false) (fun (_ : Unit) => Bool.true)
theorem congr : {α : Sort u} -> {β : Sort v} -> {f₁ : α -> β} -> {f₂ : α -> β} -> {a₁ : α} -> {a₂ : α} -> @Eq (α -> β) f₁ f₂ -> @Eq α a₁ a₂ -> @Eq β (f₁ a₁) (f₂ a₂) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {f₁ : α -> β} => fun {f₂ : α -> β} => fun {a₁ : α} => fun {a₂ : α} => fun (h₁ : @Eq (α -> β) f₁ f₂) => fun (h₂ : @Eq α a₁ a₂) => @Eq.rec (α -> β) f₁ (fun (x : α -> β) => fun (_ : @Eq (α -> β) f₁ x) => @Eq β (f₁ a₁) (x a₂)) (@Eq.rec α a₁ (fun (x : α) => fun (_ : @Eq α a₁ x) => @Eq β (f₁ a₁) (f₁ x)) (@rfl β (f₁ a₁)) a₂ h₂) f₂ h₁
theorem Bool.not_false : @Eq Bool (@Bool.not Bool.false) Bool.true :=
  @of_decide_eq_true (@Eq Bool (@Bool.not Bool.false) Bool.true) (@instDecidableEqBool (@Bool.not Bool.false) Bool.true) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.not Bool.false) Bool.true) (@instDecidableEqBool (@Bool.not Bool.false) Bool.true)) Bool.true) (@Eq.refl Bool Bool.true))
theorem iff_self : (p : Prop) -> @Eq Prop (@Iff p p) True :=
  fun (p : Prop) => @eq_true (@Iff p p) (@Iff.rfl p)
theorem Bool.not_true : @Eq Bool (@Bool.not Bool.true) Bool.false :=
  @of_decide_eq_true (@Eq Bool (@Bool.not Bool.true) Bool.false) (@instDecidableEqBool (@Bool.not Bool.true) Bool.false) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@Bool.not Bool.true) Bool.false) (@instDecidableEqBool (@Bool.not Bool.true) Bool.false)) Bool.true) (@Eq.refl Bool Bool.true))
theorem Bool.not_eq_eq_eq_not : {a : Bool} -> {b : Bool} -> @Iff (@Eq Bool (@Bool.not a) b) (@Eq Bool a (@Bool.not b)) :=
  fun {a : Bool} => fun {b : Bool} => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Iff (@Eq Bool (@Bool.not a) b) (@Eq Bool a (@Bool.not b))) a (fun (h : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun {a1 : Bool} => @Iff (@Eq Bool (@Bool.not a1) b) (@Eq Bool a1 (@Bool.not b))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Iff (@Eq Bool (@Bool.not Bool.false) b) (@Eq Bool Bool.false (@Bool.not b))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Iff (@Eq Bool (@Bool.not Bool.false) b1) (@Eq Bool Bool.false (@Bool.not b1))) (@of_eq_true (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.false) (@Eq Bool Bool.false (@Bool.not Bool.false))) (@Eq.trans Prop (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.false) (@Eq Bool Bool.false (@Bool.not Bool.false))) (@Iff False False) True (@congr Prop Prop (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.false)) (@Iff False) (@Eq Bool Bool.false (@Bool.not Bool.false)) False (@congrArg Prop (Prop -> Prop) (@Eq Bool (@Bool.not Bool.false) Bool.false) False Iff (@Eq.trans Prop (@Eq Bool (@Bool.not Bool.false) Bool.false) (@Eq Bool Bool.true Bool.false) False (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (fun (x : Bool) => @Eq Bool x Bool.false) Bool.not_false) (@eq_false' (@Eq Bool Bool.true Bool.false) Bool.neq))) (@Eq.trans Prop (@Eq Bool Bool.false (@Bool.not Bool.false)) (@Eq Bool Bool.false Bool.true) False (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (@Eq Bool Bool.false) Bool.not_false) (@eq_false' (@Eq Bool Bool.false Bool.true) Bool.neqr))) (@iff_self False))) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Iff (@Eq Bool (@Bool.not Bool.false) b1) (@Eq Bool Bool.false (@Bool.not b1))) (@of_eq_true (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.true) (@Eq Bool Bool.false (@Bool.not Bool.true))) (@Eq.trans Prop (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.true) (@Eq Bool Bool.false (@Bool.not Bool.true))) (@Iff True True) True (@congr Prop Prop (@Iff (@Eq Bool (@Bool.not Bool.false) Bool.true)) (@Iff True) (@Eq Bool Bool.false (@Bool.not Bool.true)) True (@congrArg Prop (Prop -> Prop) (@Eq Bool (@Bool.not Bool.false) Bool.true) True Iff (@Eq.trans Prop (@Eq Bool (@Bool.not Bool.false) Bool.true) (@Eq Bool Bool.true Bool.true) True (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (fun (x : Bool) => @Eq Bool x Bool.true) Bool.not_false) (@eq_self Bool Bool.true))) (@Eq.trans Prop (@Eq Bool Bool.false (@Bool.not Bool.true)) (@Eq Bool Bool.false Bool.false) True (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool Bool.false) Bool.not_true) (@eq_self Bool Bool.false))) (@iff_self True))) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.false h)) (fun (h : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun {a1 : Bool} => @Iff (@Eq Bool (@Bool.not a1) b) (@Eq Bool a1 (@Bool.not b))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Iff (@Eq Bool (@Bool.not Bool.true) b) (@Eq Bool Bool.true (@Bool.not b))) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Iff (@Eq Bool (@Bool.not Bool.true) b1) (@Eq Bool Bool.true (@Bool.not b1))) (@of_eq_true (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.false) (@Eq Bool Bool.true (@Bool.not Bool.false))) (@Eq.trans Prop (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.false) (@Eq Bool Bool.true (@Bool.not Bool.false))) (@Iff True True) True (@congr Prop Prop (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.false)) (@Iff True) (@Eq Bool Bool.true (@Bool.not Bool.false)) True (@congrArg Prop (Prop -> Prop) (@Eq Bool (@Bool.not Bool.true) Bool.false) True Iff (@Eq.trans Prop (@Eq Bool (@Bool.not Bool.true) Bool.false) (@Eq Bool Bool.false Bool.false) True (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (fun (x : Bool) => @Eq Bool x Bool.false) Bool.not_true) (@eq_self Bool Bool.false))) (@Eq.trans Prop (@Eq Bool Bool.true (@Bool.not Bool.false)) (@Eq Bool Bool.true Bool.true) True (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (@Eq Bool Bool.true) Bool.not_false) (@eq_self Bool Bool.true))) (@iff_self True))) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Iff (@Eq Bool (@Bool.not Bool.true) b1) (@Eq Bool Bool.true (@Bool.not b1))) (@of_eq_true (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.true) (@Eq Bool Bool.true (@Bool.not Bool.true))) (@Eq.trans Prop (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.true) (@Eq Bool Bool.true (@Bool.not Bool.true))) (@Iff False False) True (@congr Prop Prop (@Iff (@Eq Bool (@Bool.not Bool.true) Bool.true)) (@Iff False) (@Eq Bool Bool.true (@Bool.not Bool.true)) False (@congrArg Prop (Prop -> Prop) (@Eq Bool (@Bool.not Bool.true) Bool.true) False Iff (@Eq.trans Prop (@Eq Bool (@Bool.not Bool.true) Bool.true) (@Eq Bool Bool.false Bool.true) False (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (fun (x : Bool) => @Eq Bool x Bool.true) Bool.not_true) (@eq_false' (@Eq Bool Bool.false Bool.true) Bool.neqr))) (@Eq.trans Prop (@Eq Bool Bool.true (@Bool.not Bool.true)) (@Eq Bool Bool.true Bool.false) False (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool Bool.true) Bool.not_true) (@eq_false' (@Eq Bool Bool.true Bool.false) Bool.neq))) (@iff_self False))) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.true h)) (@Eq.refl Bool a)
theorem Init.SimpLemmas._auxLemma.22 : {a : Bool} -> {b : Bool} -> @Eq Prop (@Eq Bool (@Bool.not a) b) (@Eq Bool a (@Bool.not b)) :=
  fun {a : Bool} => fun {b : Bool} => @propext (@Eq Bool (@Bool.not a) b) (@Eq Bool a (@Bool.not b)) (@Bool.not_eq_eq_eq_not a b)
theorem not_false_eq_true : @Eq Prop (@Not False) True :=
  @eq_true (@Not False) (@False.elim False)
noncomputable def instDecidableEqOfIff.match_1 : {p : Prop} -> {q : Prop} -> (motive : @Decidable (@Iff p q) -> Sort u_1) -> (d : @Decidable (@Iff p q)) -> ((h : @Iff p q) -> motive (@Decidable.isTrue (@Iff p q) h)) -> ((h : @Not (@Iff p q)) -> motive (@Decidable.isFalse (@Iff p q) h)) -> motive d :=
  fun {p : Prop} => fun {q : Prop} => fun (motive : @Decidable (@Iff p q) -> Sort u_1) => fun (d : @Decidable (@Iff p q)) => fun (h_1 : (h : @Iff p q) -> motive (@Decidable.isTrue (@Iff p q) h)) => fun (h_2 : (h : @Not (@Iff p q)) -> motive (@Decidable.isFalse (@Iff p q) h)) => @Decidable.casesOn (@Iff p q) (fun (x : @Decidable (@Iff p q)) => motive x) d (fun (h : @Not (@Iff p q)) => h_2 h) (fun (h : @Iff p q) => h_1 h)
theorem instDecidableEqOfIff.proof_1 : {p : Prop} -> {q : Prop} -> @Not (@Iff p q) -> @Eq Prop p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Not (@Iff p q)) => fun (heq : @Eq Prop p q) => h (@Eq.rec Prop p (fun (x : Prop) => fun (_ : @Eq Prop p x) => @Iff p x) (@Iff.rfl p) q heq)
def instDecidableEqOfIff : {p : Prop} -> {q : Prop} -> @Decidable (@Iff p q) -> @Decidable (@Eq Prop p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (d : @Decidable (@Iff p q)) => @instDecidableEqOfIff.match_1 p q (fun (_ : @Decidable (@Iff p q)) => @Decidable (@Eq Prop p q)) d (fun (h : @Iff p q) => @Decidable.isTrue (@Eq Prop p q) (@propext p q h)) (fun (h : @Not (@Iff p q)) => @Decidable.isFalse (@Eq Prop p q) (@instDecidableEqOfIff.proof_1 p q h))
theorem instDecidableIff.proof_1 : {p : Prop} -> {q : Prop} -> p -> q -> @Iff p q :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : p) => fun (hq : q) => @Iff.intro p q (fun (_ : p) => hq) (fun (_ : q) => hp)
theorem instDecidableIff.proof_2 : {p : Prop} -> {q : Prop} -> p -> @Not q -> @Iff p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : p) => fun (hq : @Not q) => fun (h : @Iff p q) => hq (@Iff.mp p q h hp)
theorem instDecidableIff.proof_3 : {p : Prop} -> {q : Prop} -> @Not p -> q -> @Iff p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (hq : q) => fun (h : @Iff p q) => hp (@Iff.mpr p q h hq)
theorem instDecidableIff.proof_4 : {p : Prop} -> {q : Prop} -> @Not p -> @Not q -> @Iff p q :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (hq : @Not q) => @Iff.intro p q (fun (h : p) => @absurd p q h hp) (fun (h : q) => @absurd q p h hq)
def instDecidableIff : {p : Prop} -> {q : Prop} -> @Decidable p -> @Decidable q -> @Decidable (@Iff p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (inst : @Decidable p) => fun (inst1 : @Decidable q) => @dite (@Decidable (@Iff p q)) p inst (fun (hp : p) => @dite (@Decidable (@Iff p q)) q inst1 (fun (hq : q) => @Decidable.isTrue (@Iff p q) (@instDecidableIff.proof_1 p q hp hq)) (fun (hq : @Not q) => @Decidable.isFalse (@Iff p q) (@instDecidableIff.proof_2 p q hp hq))) (fun (hp : @Not p) => @dite (@Decidable (@Iff p q)) q inst1 (fun (hq : q) => @Decidable.isFalse (@Iff p q) (@instDecidableIff.proof_3 p q hp hq)) (fun (hq : @Not q) => @Decidable.isTrue (@Iff p q) (@instDecidableIff.proof_4 p q hp hq)))
def instDecidableAnd.match_1 : {q : Prop} -> (motive : @Decidable q -> Sort u_1) -> (dq : @Decidable q) -> ((hq : q) -> motive (@Decidable.isTrue q hq)) -> ((hq : @Not q) -> motive (@Decidable.isFalse q hq)) -> motive dq :=
  fun {q : Prop} => fun (motive : @Decidable q -> Sort u_1) => fun (dq : @Decidable q) => fun (h_1 : (hq : q) -> motive (@Decidable.isTrue q hq)) => fun (h_2 : (hq : @Not q) -> motive (@Decidable.isFalse q hq)) => @Decidable.casesOn q (fun (x : @Decidable q) => motive x) dq (fun (h : @Not q) => h_2 h) (fun (h : q) => h_1 h)
def instDecidableNot : {p : Prop} -> @Decidable p -> @Decidable (@Not p) :=
  fun {p : Prop} => fun (dp : @Decidable p) => @instDecidableAnd.match_1 p (fun (_ : @Decidable p) => @Decidable (@Not p)) dp (fun (hp : p) => @Decidable.isFalse (@Not p) (@absurd p False hp)) (fun (hp : @Not p) => @Decidable.isTrue (@Not p) hp)
theorem not_true_eq_false : @Eq Prop (@Not True) False :=
  @of_decide_eq_true (@Eq Prop (@Not True) False) (@instDecidableEqOfIff (@Not True) False (@instDecidableIff (@Not True) False (@instDecidableNot True instDecidableTrue) instDecidableFalse)) (@id (@Eq Bool (@Decidable.decide (@Eq Prop (@Not True) False) (@instDecidableEqOfIff (@Not True) False (@instDecidableIff (@Not True) False (@instDecidableNot True instDecidableTrue) instDecidableFalse))) Bool.true) (@Eq.refl Bool Bool.true))
theorem Bool.not_eq_not : {a : Bool} -> {b : Bool} -> @Iff (@Not (@Eq Bool a (@Bool.not b))) (@Eq Bool a b) :=
  fun {a : Bool} => fun {b : Bool} => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Iff (@Not (@Eq Bool a (@Bool.not b))) (@Eq Bool a b)) a (fun (h : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun {a1 : Bool} => @Iff (@Not (@Eq Bool a1 (@Bool.not b))) (@Eq Bool a1 b)) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Iff (@Not (@Eq Bool Bool.false (@Bool.not b))) (@Eq Bool Bool.false b)) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Iff (@Not (@Eq Bool Bool.false (@Bool.not b1))) (@Eq Bool Bool.false b1)) (@of_eq_true (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.false))) (@Eq Bool Bool.false Bool.false)) (@Eq.trans Prop (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.false))) (@Eq Bool Bool.false Bool.false)) (@Iff True True) True (@congr Prop Prop (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.false)))) (@Iff True) (@Eq Bool Bool.false Bool.false) True (@congrArg Prop (Prop -> Prop) (@Not (@Eq Bool Bool.false (@Bool.not Bool.false))) True Iff (@Eq.trans Prop (@Not (@Eq Bool Bool.false (@Bool.not Bool.false))) (@Not False) True (@congrArg Prop Prop (@Eq Bool Bool.false (@Bool.not Bool.false)) False Not (@Eq.trans Prop (@Eq Bool Bool.false (@Bool.not Bool.false)) (@Eq Bool Bool.false Bool.true) False (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (@Eq Bool Bool.false) Bool.not_false) (@eq_false' (@Eq Bool Bool.false Bool.true) Bool.neqr))) not_false_eq_true)) (@eq_self Bool Bool.false)) (@iff_self True))) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Iff (@Not (@Eq Bool Bool.false (@Bool.not b1))) (@Eq Bool Bool.false b1)) (@of_eq_true (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.true))) (@Eq Bool Bool.false Bool.true)) (@Eq.trans Prop (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.true))) (@Eq Bool Bool.false Bool.true)) (@Iff False False) True (@congr Prop Prop (@Iff (@Not (@Eq Bool Bool.false (@Bool.not Bool.true)))) (@Iff False) (@Eq Bool Bool.false Bool.true) False (@congrArg Prop (Prop -> Prop) (@Not (@Eq Bool Bool.false (@Bool.not Bool.true))) False Iff (@Eq.trans Prop (@Not (@Eq Bool Bool.false (@Bool.not Bool.true))) (@Not True) False (@congrArg Prop Prop (@Eq Bool Bool.false (@Bool.not Bool.true)) True Not (@Eq.trans Prop (@Eq Bool Bool.false (@Bool.not Bool.true)) (@Eq Bool Bool.false Bool.false) True (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool Bool.false) Bool.not_true) (@eq_self Bool Bool.false))) not_true_eq_false)) (@eq_false' (@Eq Bool Bool.false Bool.true) Bool.neqr)) (@iff_self False))) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.false h)) (fun (h : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun {a1 : Bool} => @Iff (@Not (@Eq Bool a1 (@Bool.not b))) (@Eq Bool a1 b)) (@Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Iff (@Not (@Eq Bool Bool.true (@Bool.not b))) (@Eq Bool Bool.true b)) b (fun (h1 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Iff (@Not (@Eq Bool Bool.true (@Bool.not b1))) (@Eq Bool Bool.true b1)) (@of_eq_true (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.false))) (@Eq Bool Bool.true Bool.false)) (@Eq.trans Prop (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.false))) (@Eq Bool Bool.true Bool.false)) (@Iff False False) True (@congr Prop Prop (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.false)))) (@Iff False) (@Eq Bool Bool.true Bool.false) False (@congrArg Prop (Prop -> Prop) (@Not (@Eq Bool Bool.true (@Bool.not Bool.false))) False Iff (@Eq.trans Prop (@Not (@Eq Bool Bool.true (@Bool.not Bool.false))) (@Not True) False (@congrArg Prop Prop (@Eq Bool Bool.true (@Bool.not Bool.false)) True Not (@Eq.trans Prop (@Eq Bool Bool.true (@Bool.not Bool.false)) (@Eq Bool Bool.true Bool.true) True (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (@Eq Bool Bool.true) Bool.not_false) (@eq_self Bool Bool.true))) not_true_eq_false)) (@eq_false' (@Eq Bool Bool.true Bool.false) Bool.neq)) (@iff_self False))) b (@Eq.symm Bool b Bool.false h1)) (fun (h1 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Iff (@Not (@Eq Bool Bool.true (@Bool.not b1))) (@Eq Bool Bool.true b1)) (@of_eq_true (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.true))) (@Eq Bool Bool.true Bool.true)) (@Eq.trans Prop (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.true))) (@Eq Bool Bool.true Bool.true)) (@Iff True True) True (@congr Prop Prop (@Iff (@Not (@Eq Bool Bool.true (@Bool.not Bool.true)))) (@Iff True) (@Eq Bool Bool.true Bool.true) True (@congrArg Prop (Prop -> Prop) (@Not (@Eq Bool Bool.true (@Bool.not Bool.true))) True Iff (@Eq.trans Prop (@Not (@Eq Bool Bool.true (@Bool.not Bool.true))) (@Not False) True (@congrArg Prop Prop (@Eq Bool Bool.true (@Bool.not Bool.true)) False Not (@Eq.trans Prop (@Eq Bool Bool.true (@Bool.not Bool.true)) (@Eq Bool Bool.true Bool.false) False (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool Bool.true) Bool.not_true) (@eq_false' (@Eq Bool Bool.true Bool.false) Bool.neq))) not_false_eq_true)) (@eq_self Bool Bool.true)) (@iff_self True))) b (@Eq.symm Bool b Bool.true h1)) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.true h)) (@Eq.refl Bool a)
theorem Init.SimpLemmas._auxLemma_23 : {a : Bool} -> {b : Bool} -> @Eq Prop (@Not (@Eq Bool a (@Bool.not b))) (@Eq Bool a b) :=
  fun {a : Bool} => fun {b : Bool} => @propext (@Not (@Eq Bool a (@Bool.not b))) (@Eq Bool a b) (@Bool.not_eq_not a b)
theorem Bool.not_not_eq : {a : Bool} -> {b : Bool} -> @Iff (@Not (@Eq Bool (@Bool.not a) b)) (@Eq Bool a b) :=
  fun {a : Bool} => fun {b : Bool} => @of_eq_true (@Iff (@Not (@Eq Bool (@Bool.not a) b)) (@Eq Bool a b)) (@Eq.trans Prop (@Iff (@Not (@Eq Bool (@Bool.not a) b)) (@Eq Bool a b)) (@Iff (@Eq Bool a b) (@Eq Bool a b)) True (@congrArg Prop Prop (@Not (@Eq Bool (@Bool.not a) b)) (@Eq Bool a b) (fun (x : Prop) => @Iff x (@Eq Bool a b)) (@Eq.trans Prop (@Not (@Eq Bool (@Bool.not a) b)) (@Not (@Eq Bool a (@Bool.not b))) (@Eq Bool a b) (@congrArg Prop Prop (@Eq Bool (@Bool.not a) b) (@Eq Bool a (@Bool.not b)) Not (@Init.SimpLemmas._auxLemma_22 a b)) (@Init.SimpLemmas._auxLemma_23 a b))) (@iff_self (@Eq Bool a b)))
theorem Bool.not_eq_true' : (b : Bool) -> @Eq Prop (@Eq Bool (@Bool.not b) Bool.true) (@Eq Bool b Bool.false) :=
  fun (b : Bool) => @of_eq_true (@Eq Prop (@Eq Bool (@Bool.not b) Bool.true) (@Eq Bool b Bool.false)) (@Eq.trans Prop (@Eq Prop (@Eq Bool (@Bool.not b) Bool.true) (@Eq Bool b Bool.false)) (@Eq Prop (@Eq Bool b Bool.false) (@Eq Bool b Bool.false)) True (@congrArg Prop Prop (@Eq Bool (@Bool.not b) Bool.true) (@Eq Bool b Bool.false) (fun (x : Prop) => @Eq Prop x (@Eq Bool b Bool.false)) (@Eq.trans Prop (@Eq Bool (@Bool.not b) Bool.true) (@Eq Bool b (@Bool.not Bool.true)) (@Eq Bool b Bool.false) (@Init.SimpLemmas._auxLemma_22 b Bool.true) (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool b) Bool.not_true))) (@eq_self Prop (@Eq Bool b Bool.false)))
theorem Bool.not_eq_false' : (b : Bool) -> @Eq Prop (@Eq Bool (@Bool.not b) Bool.false) (@Eq Bool b Bool.true) :=
  fun (b : Bool) => @of_eq_true (@Eq Prop (@Eq Bool (@Bool.not b) Bool.false) (@Eq Bool b Bool.true)) (@Eq.trans Prop (@Eq Prop (@Eq Bool (@Bool.not b) Bool.false) (@Eq Bool b Bool.true)) (@Eq Prop (@Eq Bool b Bool.true) (@Eq Bool b Bool.true)) True (@congrArg Prop Prop (@Eq Bool (@Bool.not b) Bool.false) (@Eq Bool b Bool.true) (fun (x : Prop) => @Eq Prop x (@Eq Bool b Bool.true)) (@Eq.trans Prop (@Eq Bool (@Bool.not b) Bool.false) (@Eq Bool b (@Bool.not Bool.false)) (@Eq Bool b Bool.true) (@Init.SimpLemmas._auxLemma_22 b Bool.false) (@congrArg Bool Prop (@Bool.not Bool.false) Bool.true (@Eq Bool b) Bool.not_false))) (@eq_self Prop (@Eq Bool b Bool.true)))
theorem decide_eq_false_iff_not : {p : Prop} -> {x : @Decidable p} -> @Iff (@Eq Bool (@Decidable.decide p x) Bool.false) (@Not p) :=
  fun {p : Prop} => fun {x : @Decidable p} => @Iff.intro (@Eq Bool (@Decidable.decide p x) Bool.false) (@Not p) (@of_decide_eq_false p x) (@decide_eq_false p x)
theorem Init.SimpLemmas._auxLemma_24 : {p : Prop} -> {x : @Decidable p} -> @Eq Prop (@Eq Bool (@Decidable.decide p x) Bool.false) (@Not p) :=
  fun {p : Prop} => fun {x : @Decidable p} => @propext (@Eq Bool (@Decidable.decide p x) Bool.false) (@Not p) (@decide_eq_false_iff_not p x)
theorem not_decide_eq_true : {p : Prop} -> (h : @Decidable p) -> @Eq Prop (@Eq Bool (@Bool.not (@Decidable.decide p h)) Bool.true) (@Not p) :=
  fun {p : Prop} => fun (h : @Decidable p) => @of_eq_true (@Eq Prop (@Eq Bool (@Bool.not (@Decidable.decide p h)) Bool.true) (@Not p)) (@Eq.trans Prop (@Eq Prop (@Eq Bool (@Bool.not (@Decidable.decide p h)) Bool.true) (@Not p)) (@Eq Prop (@Not p) (@Not p)) True (@congrArg Prop Prop (@Eq Bool (@Bool.not (@Decidable.decide p h)) Bool.true) (@Not p) (fun (x : Prop) => @Eq Prop x (@Not p)) (@Eq.trans Prop (@Eq Bool (@Bool.not (@Decidable.decide p h)) Bool.true) (@Eq Bool (@Decidable.decide p h) (@Bool.not Bool.true)) (@Not p) (@Init.SimpLemmas._auxLemma_22 (@Decidable.decide p h) Bool.true) (@Eq.trans Prop (@Eq Bool (@Decidable.decide p h) (@Bool.not Bool.true)) (@Eq Bool (@Decidable.decide p h) Bool.false) (@Not p) (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool (@Decidable.decide p h)) Bool.not_true) (@Init.SimpLemmas._auxLemma_24 p h)))) (@eq_self Prop (@Not p)))
axiom BEq : Type u -> Type u
axiom BEq.beq : {α : Type u} -> @BEq α -> α -> α -> Bool
axiom BEq.mk : {α : Type u} -> (α -> α -> Bool) -> @BEq α
noncomputable def instBEqOfDecidableEq : {α : Type u_1} -> @DecidableEq α -> @BEq α :=
  fun {α : Type u_1} => fun (inst : @DecidableEq α) => @BEq.mk α (fun (a : α) => fun (b : α) => @Decidable.decide (@Eq α a b) (inst a b))
axiom LawfulBEq : (α : Type u) -> @BEq α -> Prop
axiom LawfulBEq.rfl : {α : Type u} -> {inst : @BEq α} -> @LawfulBEq α inst -> {a : α} -> @Eq Bool (@BEq.beq α inst a a) Bool.true
theorem beq_self_eq_true : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> (a : α) -> @Eq Bool (@BEq.beq α inst a a) Bool.true :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun (a : α) => @LawfulBEq.rfl α inst inst1 a
axiom LawfulBEq.mk : {α : Type u} -> (inst : @BEq α) -> ({a : α} -> {b : α} -> @Eq Bool (@BEq.beq α inst a b) Bool.true -> @Eq α a b) -> ({a : α} -> @Eq Bool (@BEq.beq α inst a a) Bool.true) -> @LawfulBEq α inst
def of_decide_eq_self_eq_true.match_1 : {α : Sort u_1} -> (a : α) -> (motive : @Decidable (@Eq α a a) -> Prop) -> (x : @Decidable (@Eq α a a)) -> ((h : @Eq α a a) -> motive (@Decidable.isTrue (@Eq α a a) h)) -> ((h₁ : @Not (@Eq α a a)) -> motive (@Decidable.isFalse (@Eq α a a) h₁)) -> motive x :=
  fun {α : Sort u_1} => fun (a : α) => fun (motive : @Decidable (@Eq α a a) -> Prop) => fun (x : @Decidable (@Eq α a a)) => fun (h_1 : (h : @Eq α a a) -> motive (@Decidable.isTrue (@Eq α a a) h)) => fun (h_2 : (h₁ : @Not (@Eq α a a)) -> motive (@Decidable.isFalse (@Eq α a a) h₁)) => @Decidable.casesOn (@Eq α a a) (fun (x1 : @Decidable (@Eq α a a)) => motive x1) x (fun (h : @Not (@Eq α a a)) => h_2 h) (fun (h : @Eq α a a) => h_1 h)
theorem of_decide_eq_self_eq_true : {α : Sort u_1} -> (inst : @DecidableEq α) -> (a : α) -> @Eq Bool (@Decidable.decide (@Eq α a a) (inst a a)) Bool.true :=
  fun {α : Sort u_1} => fun (inst : @DecidableEq α) => fun (a : α) => @of_decide_eq_self_eq_true.match_1 α a (fun (x : @Decidable (@Eq α a a)) => @Eq Bool (@Decidable.decide (@Eq α a a) x) Bool.true) (inst a a) (fun (h : @Eq α a a) => @rfl Bool (@Decidable.decide (@Eq α a a) (@Decidable.isTrue (@Eq α a a) h))) (fun (h₁ : @Not (@Eq α a a)) => @absurd (@Eq α a a) (@Eq Bool (@Decidable.decide (@Eq α a a) (@Decidable.isFalse (@Eq α a a) h₁)) Bool.true) (@rfl α a) h₁)
theorem instLawfulBEq : {α : Type u_1} -> (inst : @DecidableEq α) -> @LawfulBEq α (@instBEqOfDecidableEq α inst) :=
  fun {α : Type u_1} => fun (inst : @DecidableEq α) => @LawfulBEq.mk α (@instBEqOfDecidableEq α inst) (fun {a : α} => fun {b : α} => @of_decide_eq_true (@Eq α a b) (inst a b)) (fun {a : α} => @of_decide_eq_self_eq_true α inst a)
theorem beq_self_eq_true' : {α : Type u_1} -> (inst : @DecidableEq α) -> (a : α) -> @Eq Bool (@BEq.beq α (@instBEqOfDecidableEq α inst) a a) Bool.true :=
  fun {α : Type u_1} => fun (inst : @DecidableEq α) => fun (a : α) => @of_eq_true (@Eq Bool (@BEq.beq α (@instBEqOfDecidableEq α inst) a a) Bool.true) (@Eq.trans Prop (@Eq Bool (@BEq.beq α (@instBEqOfDecidableEq α inst) a a) Bool.true) (@Eq Bool Bool.true Bool.true) True (@congrArg Bool Prop (@BEq.beq α (@instBEqOfDecidableEq α inst) a a) Bool.true (fun (x : Bool) => @Eq Bool x Bool.true) (@beq_self_eq_true α (@instBEqOfDecidableEq α inst) (@instLawfulBEq α inst) a)) (@eq_self Bool Bool.true))
noncomputable def bne : {α : Type u} -> @BEq α -> α -> α -> Bool :=
  fun {α : Type u} => fun (inst : @BEq α) => fun (a : α) => fun (b : α) => @Bool.not (@BEq.beq α inst a b)
theorem bne_self_eq_false : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> (a : α) -> @Eq Bool (@bne α inst a a) Bool.false :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun (a : α) => @of_eq_true (@Eq Bool (@Bool.not (@BEq.beq α inst a a)) Bool.false) (@Eq.trans Prop (@Eq Bool (@Bool.not (@BEq.beq α inst a a)) Bool.false) (@Eq Bool Bool.false Bool.false) True (@congrArg Bool Prop (@Bool.not (@BEq.beq α inst a a)) Bool.false (fun (x : Bool) => @Eq Bool x Bool.false) (@Eq.trans Bool (@Bool.not (@BEq.beq α inst a a)) (@Bool.not Bool.true) Bool.false (@congrArg Bool Bool (@BEq.beq α inst a a) Bool.true Bool.not (@beq_self_eq_true α inst inst1 a)) Bool.not_true)) (@eq_self Bool Bool.false))
theorem bne_self_eq_false' : {α : Type u_1} -> (inst : @DecidableEq α) -> (a : α) -> @Eq Bool (@bne α (@instBEqOfDecidableEq α inst) a a) Bool.false :=
  fun {α : Type u_1} => fun (inst : @DecidableEq α) => fun (a : α) => @of_eq_true (@Eq Bool (@bne α (@instBEqOfDecidableEq α inst) a a) Bool.false) (@Eq.trans Prop (@Eq Bool (@bne α (@instBEqOfDecidableEq α inst) a a) Bool.false) (@Eq Bool Bool.false Bool.false) True (@congrArg Bool Prop (@bne α (@instBEqOfDecidableEq α inst) a a) Bool.false (fun (x : Bool) => @Eq Bool x Bool.false) (@bne_self_eq_false α (@instBEqOfDecidableEq α inst) (@instLawfulBEq α inst) a)) (@eq_self Bool Bool.false))
axiom LawfulBEq.eq_of_beq : {α : Type u} -> {inst : @BEq α} -> @LawfulBEq α inst -> {a : α} -> {b : α} -> @Eq Bool (@BEq.beq α inst a b) Bool.true -> @Eq α a b
theorem beq_iff_eq : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> {a : α} -> {b : α} -> @Iff (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun {a : α} => fun {b : α} => @Iff.intro (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) (@LawfulBEq.eq_of_beq α inst inst1 a b) (fun (h : @Eq α a b) => @Eq.ndrec α a (fun {b1 : α} => @Eq Bool (@BEq.beq α inst a b1) Bool.true) (@LawfulBEq.rfl α inst inst1 a) b h)
theorem Init.Core._auxLemma.1 : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> {a : α} -> {b : α} -> @Eq Prop (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun {a : α} => fun {b : α} => @propext (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) (@beq_iff_eq α inst inst1 a b)
theorem instLawfulBEqBool : @LawfulBEq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) :=
  @LawfulBEq.mk Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) (fun {a : Bool} => fun {b : Bool} => fun (h : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Eq Bool a b) a (fun (h1 : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun {a1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a1 b) Bool.true -> @Eq Bool a1 b) (fun (h2 : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false b) Bool.true) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool Bool.false b) b (fun (h3 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false b1) Bool.true -> @Eq Bool Bool.false b1) (fun (_ : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) => @Eq.refl Bool Bool.false) b (@Eq.symm Bool b Bool.false h3) h2) (fun (h3 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false b1) Bool.true -> @Eq Bool Bool.false b1) (fun (h4 : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.true) Bool.true) => @Bool.noConfusion (@Eq Bool Bool.false Bool.true) (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.true) Bool.true h4) b (@Eq.symm Bool b Bool.true h3) h2) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.false h1) h) (fun (h1 : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun {a1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a1 b) Bool.true -> @Eq Bool a1 b) (fun (h2 : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true b) Bool.true) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool Bool.true b) b (fun (h3 : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun {b1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true b1) Bool.true -> @Eq Bool Bool.true b1) (fun (h4 : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.false) Bool.true) => @Bool.noConfusion (@Eq Bool Bool.true Bool.false) (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.false) Bool.true h4) b (@Eq.symm Bool b Bool.false h3) h2) (fun (h3 : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun {b1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true b1) Bool.true -> @Eq Bool Bool.true b1) (fun (_ : @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) => @Eq.refl Bool Bool.true) b (@Eq.symm Bool b Bool.true h3) h2) (@Eq.refl Bool b)) a (@Eq.symm Bool a Bool.true h1) h) (@Eq.refl Bool a)) (fun {a : Bool} => @Bool.casesOn (fun (t : Bool) => @Eq Bool a t -> @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a a) Bool.true) a (fun (h : @Eq Bool a Bool.false) => @Eq.ndrec Bool Bool.false (fun {a1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a1 a1) Bool.true) (@of_decide_eq_true (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (@instDecidableEqBool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (@instDecidableEqBool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true)) Bool.true) (@Eq.refl Bool Bool.true))) a (@Eq.symm Bool a Bool.false h)) (fun (h : @Eq Bool a Bool.true) => @Eq.ndrec Bool Bool.true (fun {a1 : Bool} => @Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a1 a1) Bool.true) (@of_decide_eq_true (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (@instDecidableEqBool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (@id (@Eq Bool (@Decidable.decide (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (@instDecidableEqBool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true)) Bool.true) (@Eq.refl Bool Bool.true))) a (@Eq.symm Bool a Bool.true h)) (@Eq.refl Bool a))
theorem Bool.beq_to_eq : (a : Bool) -> (b : Bool) -> @Eq Prop (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (@Eq Bool a b) :=
  fun (a : Bool) => fun (b : Bool) => @of_eq_true (@Eq Prop (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (@Eq Bool a b)) (@Eq.trans Prop (@Eq Prop (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (@Eq Bool a b)) (@Eq Prop (@Eq Bool a b) (@Eq Bool a b)) True (@congrArg Prop Prop (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (@Eq Bool a b) (fun (x : Prop) => @Eq Prop x (@Eq Bool a b)) (@Init.Core._auxLemma_1 Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) instLawfulBEqBool a b)) (@eq_self Prop (@Eq Bool a b)))
def Ne : {α : Sort u} -> α -> α -> Prop :=
  fun {α : Sort u} => fun (a : α) => fun (b : α) => @Not (@Eq α a b)
theorem ne_eq : {α : Sort u_1} -> (a : α) -> (b : α) -> @Eq Prop (@Ne α a b) (@Not (@Eq α a b)) :=
  fun {α : Sort u_1} => fun (a : α) => fun (b : α) => @rfl Prop (@Ne α a b)
theorem beq_eq_false_iff_ne : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> {a : α} -> {b : α} -> @Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Ne α a b) :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun {a : α} => fun {b : α} => @Eq.mpr (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Ne α a b)) (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq α a b))) (@id (@Eq Prop (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Ne α a b)) (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq α a b)))) (@congrArg Prop Prop (@Ne α a b) (@Not (@Eq α a b)) (fun (_a : Prop) => @Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) _a) (@ne_eq α a b))) (@Eq.mpr (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq α a b))) (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq Bool (@BEq.beq α inst a b) Bool.true))) (@id (@Eq Prop (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq α a b))) (@Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq Bool (@BEq.beq α inst a b) Bool.true)))) (@congrArg Prop Prop (@Eq α a b) (@Eq Bool (@BEq.beq α inst a b) Bool.true) (fun (_a : Prop) => @Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not _a)) (@Eq.symm Prop (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) (@propext (@Eq Bool (@BEq.beq α inst a b) Bool.true) (@Eq α a b) (@beq_iff_eq α inst inst1 a b))))) (@Bool.casesOn (fun (t : Bool) => @Eq Bool (@BEq.beq α inst a b) t -> @Iff (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Not (@Eq Bool (@BEq.beq α inst a b) Bool.true))) (@BEq.beq α inst a b) (fun (h : @Eq Bool (@BEq.beq α inst a b) Bool.false) => @Eq.ndrec Bool Bool.false (fun (x : Bool) => @Iff (@Eq Bool x Bool.false) (@Not (@Eq Bool x Bool.true))) (@of_decide_eq_true (@Iff (@Eq Bool Bool.false Bool.false) (@Not (@Eq Bool Bool.false Bool.true))) (@instDecidableIff (@Eq Bool Bool.false Bool.false) (@Not (@Eq Bool Bool.false Bool.true)) (@instDecidableEqBool Bool.false Bool.false) (@instDecidableNot (@Eq Bool Bool.false Bool.true) (@instDecidableEqBool Bool.false Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Iff (@Eq Bool Bool.false Bool.false) (@Not (@Eq Bool Bool.false Bool.true))) (@instDecidableIff (@Eq Bool Bool.false Bool.false) (@Not (@Eq Bool Bool.false Bool.true)) (@instDecidableEqBool Bool.false Bool.false) (@instDecidableNot (@Eq Bool Bool.false Bool.true) (@instDecidableEqBool Bool.false Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) (@BEq.beq α inst a b) (@Eq.symm Bool (@BEq.beq α inst a b) Bool.false h)) (fun (h : @Eq Bool (@BEq.beq α inst a b) Bool.true) => @Eq.ndrec Bool Bool.true (fun (x : Bool) => @Iff (@Eq Bool x Bool.false) (@Not (@Eq Bool x Bool.true))) (@of_decide_eq_true (@Iff (@Eq Bool Bool.true Bool.false) (@Not (@Eq Bool Bool.true Bool.true))) (@instDecidableIff (@Eq Bool Bool.true Bool.false) (@Not (@Eq Bool Bool.true Bool.true)) (@instDecidableEqBool Bool.true Bool.false) (@instDecidableNot (@Eq Bool Bool.true Bool.true) (@instDecidableEqBool Bool.true Bool.true))) (@id (@Eq Bool (@Decidable.decide (@Iff (@Eq Bool Bool.true Bool.false) (@Not (@Eq Bool Bool.true Bool.true))) (@instDecidableIff (@Eq Bool Bool.true Bool.false) (@Not (@Eq Bool Bool.true Bool.true)) (@instDecidableEqBool Bool.true Bool.false) (@instDecidableNot (@Eq Bool Bool.true Bool.true) (@instDecidableEqBool Bool.true Bool.true)))) Bool.true) (@Eq.refl Bool Bool.true))) (@BEq.beq α inst a b) (@Eq.symm Bool (@BEq.beq α inst a b) Bool.true h)) (@Eq.refl Bool (@BEq.beq α inst a b))))
theorem Init.SimpLemmas._auxLemma.26 : {α : Type u_1} -> (inst : @BEq α) -> @LawfulBEq α inst -> {a : α} -> {b : α} -> @Eq Prop (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Ne α a b) :=
  fun {α : Type u_1} => fun (inst : @BEq α) => fun (inst1 : @LawfulBEq α inst) => fun {a : α} => fun {b : α} => @propext (@Eq Bool (@BEq.beq α inst a b) Bool.false) (@Ne α a b) (@beq_eq_false_iff_ne α inst inst1 a b)
theorem Bool.not_beq_to_not_eq : (a : Bool) -> (b : Bool) -> @Eq Prop (@Eq Bool (@Bool.not (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (@Not (@Eq Bool a b)) :=
  fun (a : Bool) => fun (b : Bool) => @of_eq_true (@Eq Prop (@Eq Bool (@Bool.not (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (@Not (@Eq Bool a b))) (@Eq.trans Prop (@Eq Prop (@Eq Bool (@Bool.not (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (@Not (@Eq Bool a b))) (@Eq Prop (@Ne Bool a b) (@Not (@Eq Bool a b))) True (@congrArg Prop Prop (@Eq Bool (@Bool.not (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (@Ne Bool a b) (fun (x : Prop) => @Eq Prop x (@Not (@Eq Bool a b))) (@Eq.trans Prop (@Eq Bool (@Bool.not (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) (@Bool.not Bool.true)) (@Ne Bool a b) (@Init.SimpLemmas._auxLemma_22 (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (@Eq.trans Prop (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) (@Bool.not Bool.true)) (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.false) (@Ne Bool a b) (@congrArg Bool Prop (@Bool.not Bool.true) Bool.false (@Eq Bool (@BEq.beq Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.not_true) (@Init.SimpLemmas._auxLemma_26 Bool (@instBEqOfDecidableEq Bool instDecidableEqBool) instLawfulBEqBool a b)))) (@eq_self Prop (@Not (@Eq Bool a b))))
